import{a as Ue,b as ze,c as $s,d as Ar,e as pn,f as Vs,g as Gs,h as qs,i as Hs,j as ua,k as yn,p as da}from"./chunk-LXRKHC5Y.js";import{a as js,b as wr,c as fa}from"./chunk-5OD6RQ4E.js";import{a as mr,b as ia}from"./chunk-4S6FFY6F.js";import{c as hn,e as Ks,h as _n,j as Sr,k as $e,l as Er,o as Nt,s as Ws,t as br,u as ca}from"./chunk-ZKF2PX52.js";import{a as Ir,b as la}from"./chunk-NAEIWTZ5.js";import{b as Fs,c as aa}from"./chunk-62642RW2.js";import{I as Ms,J as oa}from"./chunk-BSLHOIZQ.js";import{a as C,b as F,d as De,e as te,f as pt,g as gr,i as et,j as Rr,l as y}from"./chunk-JOVT4LBN.js";function pa(r){let e=Hs(r);return Ws(r,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze(C({},e))}function Xs(r){let e=pa(r),{Fp:t,n,prehash:s,hash:o,randomBytes:i,nByteLength:a,h:c}=e,l=Ys<<BigInt(a*8)-Ie,d=t.create,_=pn(e.n,e.nBitLength);function I(D,b){let L=t.sqr(D),x=t.sqr(b),W=t.add(t.mul(e.a,L),x),V=t.add(t.ONE,t.mul(e.d,t.mul(L,x)));return t.eql(W,V)}if(!I(e.Gx,e.Gy))throw new Error("bad curve params: generator point");let p=e.uvRatio||((D,b)=>{try{return{isValid:!0,value:t.sqrt(D*t.inv(b))}}catch{return{isValid:!1,value:Ve}}}),g=e.adjustScalarBytes||(D=>D),R=e.domain||((D,b,L)=>{if(hn("phflag",L),b.length||L)throw new Error("Contexts/pre-hash are not supported");return D});function S(D,b,L=!1){let x=L?Ie:Ve;Nt("coordinate "+D,b,x,l)}function N(D){if(!(D instanceof v))throw new Error("ExtendedPoint expected")}let M=br((D,b)=>{let{ex:L,ey:x,ez:W}=D,V=D.is0();b==null&&(b=V?ha:t.inv(W));let se=d(L*b),ce=d(x*b),ne=d(W*b);if(V)return{x:Ve,y:Ie};if(ne!==Ie)throw new Error("invZ was invalid");return{x:se,y:ce}}),Z=br(D=>{let{a:b,d:L}=e;if(D.is0())throw new Error("bad point: ZERO");let{ex:x,ey:W,ez:V,et:se}=D,ce=d(x*x),ne=d(W*W),ae=d(V*V),ye=d(ae*ae),ve=d(ce*b),Ke=d(ae*d(ve+ne)),We=d(ye+d(L*d(ce*ne)));if(Ke!==We)throw new Error("bad point: equation left != right (1)");let xe=d(x*W),ot=d(V*se);if(xe!==ot)throw new Error("bad point: equation left != right (2)");return!0});class v{constructor(b,L,x,W){S("x",b),S("y",L),S("z",x,!0),S("t",W),this.ex=b,this.ey=L,this.ez=x,this.et=W,Object.freeze(this)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(b){if(b instanceof v)throw new Error("extended point not allowed");let{x:L,y:x}=b||{};return S("x",L),S("y",x),new v(L,x,Ie,d(L*x))}static normalizeZ(b){let L=Ar(t,b.map(x=>x.ez));return b.map((x,W)=>x.toAffine(L[W])).map(v.fromAffine)}static msm(b,L){return qs(v,_,b,L)}_setWindowSize(b){ue.setWindowSize(this,b)}assertValidity(){Z(this)}equals(b){N(b);let{ex:L,ey:x,ez:W}=this,{ex:V,ey:se,ez:ce}=b,ne=d(L*ce),ae=d(V*W),ye=d(x*ce),ve=d(se*W);return ne===ae&&ye===ve}is0(){return this.equals(v.ZERO)}negate(){return new v(d(-this.ex),this.ey,this.ez,d(-this.et))}double(){let{a:b}=e,{ex:L,ey:x,ez:W}=this,V=d(L*L),se=d(x*x),ce=d(Ys*d(W*W)),ne=d(b*V),ae=L+x,ye=d(d(ae*ae)-V-se),ve=ne+se,Ke=ve-ce,We=ne-se,xe=d(ye*Ke),ot=d(ve*We),_t=d(ye*We),fn=d(Ke*ve);return new v(xe,ot,fn,_t)}add(b){N(b);let{a:L,d:x}=e,{ex:W,ey:V,ez:se,et:ce}=this,{ex:ne,ey:ae,ez:ye,et:ve}=b,Ke=d(W*ne),We=d(V*ae),xe=d(ce*x*ve),ot=d(se*ye),_t=d((W+V)*(ne+ae)-Ke-We),fn=ot-xe,Us=ot+xe,zs=d(We-L*Ke),ta=d(_t*fn),na=d(Us*zs),ra=d(_t*zs),sa=d(fn*Us);return new v(ta,na,sa,ra)}subtract(b){return this.add(b.negate())}wNAF(b){return ue.wNAFCached(this,b,v.normalizeZ)}multiply(b){let L=b;Nt("scalar",L,Ie,n);let{p:x,f:W}=this.wNAF(L);return v.normalizeZ([x,W])[0]}multiplyUnsafe(b,L=v.ZERO){let x=b;return Nt("scalar",x,Ve,n),x===Ve?Le:this.is0()||x===Ie?this:ue.wNAFCachedUnsafe(this,x,v.normalizeZ,L)}isSmallOrder(){return this.multiplyUnsafe(c).is0()}isTorsionFree(){return ue.unsafeLadder(this,n).is0()}toAffine(b){return M(this,b)}clearCofactor(){let{h:b}=e;return b===Ie?this:this.multiplyUnsafe(b)}static fromHex(b,L=!1){let{d:x,a:W}=e,V=t.BYTES;b=$e("pointHex",b,V),hn("zip215",L);let se=b.slice(),ce=b[V-1];se[V-1]=ce&-129;let ne=_n(se),ae=L?l:t.ORDER;Nt("pointHex.y",ne,Ve,ae);let ye=d(ne*ne),ve=d(ye-Ie),Ke=d(x*ye-W),{isValid:We,value:xe}=p(ve,Ke);if(!We)throw new Error("Point.fromHex: invalid y coordinate");let ot=(xe&Ie)===Ie,_t=(ce&128)!==0;if(!L&&xe===Ve&&_t)throw new Error("Point.fromHex: x=0 and x_0=1");return _t!==ot&&(xe=d(-xe)),v.fromAffine({x:xe,y:ne})}static fromPrivateKey(b){let{scalar:L}=Ds(b);return pe.multiply(L)}toRawBytes(){let{x:b,y:L}=this.toAffine(),x=Sr(L,t.BYTES);return x[x.length-1]|=b&Ie?128:0,x}toHex(){return Ks(this.toRawBytes())}}v.BASE=new v(e.Gx,e.Gy,Ie,d(e.Gx*e.Gy)),v.ZERO=new v(Ve,Ie,Ie,Ve);let{BASE:pe,ZERO:Le}=v,ue=Gs(v,a*8);function Qe(D){return Ue(D,n)}function ln(D){return Qe(_n(D))}function Ds(D){let b=t.BYTES;D=$e("private key",D,b);let L=$e("hashed private key",o(D),2*b),x=g(L.slice(0,b)),W=L.slice(b,2*b),V=ln(x);return{head:x,prefix:W,scalar:V}}function pr(D){let{head:b,prefix:L,scalar:x}=Ds(D),W=pe.multiply(x),V=W.toRawBytes();return{head:b,prefix:L,scalar:x,point:W,pointBytes:V}}function Ji(D){return pr(D).pointBytes}function yr(D=Uint8Array.of(),...b){let L=Er(...b);return ln(o(R(L,$e("context",D),!!s)))}function Zi(D,b,L={}){D=$e("message",D),s&&(D=s(D));let{prefix:x,scalar:W,pointBytes:V}=pr(b),se=yr(L.context,x,D),ce=pe.multiply(se).toRawBytes(),ne=yr(L.context,ce,V,D),ae=Qe(se+ne*W);Nt("signature.s",ae,Ve,n);let ye=Er(ce,Sr(ae,t.BYTES));return $e("result",ye,t.BYTES*2)}let Qi=_a;function ea(D,b,L,x=Qi){let{context:W,zip215:V}=x,se=t.BYTES;D=$e("signature",D,2*se),b=$e("message",b),L=$e("publicKey",L,se),V!==void 0&&hn("zip215",V),s&&(b=s(b));let ce=_n(D.slice(se,2*se)),ne,ae,ye;try{ne=v.fromHex(L,V),ae=v.fromHex(D.slice(0,se),V),ye=pe.multiplyUnsafe(ce)}catch{return!1}if(!V&&ne.isSmallOrder())return!1;let ve=yr(W,ae.toRawBytes(),ne.toRawBytes(),b);return ae.add(ne.multiplyUnsafe(ve)).subtract(ye).clearCofactor().equals(v.ZERO)}return pe._setWindowSize(8),{CURVE:e,getPublicKey:Ji,sign:Zi,verify:ea,ExtendedPoint:v,utils:{getExtendedPublicKey:pr,randomPrivateKey:()=>i(t.BYTES),precompute(D=8,b=v.BASE){return b._setWindowSize(D),b.multiply(BigInt(3)),b}}}}var Ve,Ie,Ys,ha,_a,Js=te(()=>{"use strict";ua();Vs();ca();Ve=BigInt(0),Ie=BigInt(1),Ys=BigInt(2),ha=BigInt(8),_a={zip215:!0}});function ma(r){let e=BigInt(10),t=BigInt(20),n=BigInt(40),s=BigInt(80),o=Or,a=r*r%o*r%o,c=ze(a,Qs,o)*a%o,l=ze(c,ya,o)*r%o,d=ze(l,ga,o)*l%o,_=ze(d,e,o)*d%o,I=ze(_,t,o)*_%o,p=ze(I,n,o)*I%o,g=ze(p,s,o)*p%o,R=ze(g,s,o)*p%o,S=ze(R,e,o)*d%o;return{pow_p_5_8:ze(S,Qs,o)*r%o,b2:a}}function Sa(r){return r[0]&=248,r[31]&=127,r[31]|=64,r}function Ea(r,e){let t=Or,n=Ue(e*e*e,t),s=Ue(n*n*e,t),o=ma(r*s).pow_p_5_8,i=Ue(r*n*o,t),a=Ue(e*i*i,t),c=i,l=Ue(i*Zs,t),d=a===r,_=a===Ue(-r,t),I=a===Ue(-r*Zs,t);return d&&(i=c),(_||I)&&(i=l),$s(i,t)&&(i=Ue(-i,t)),{isValid:d||_,value:i}}var Or,Zs,Y_,ya,Qs,X_,ga,Ra,eo,ba,yt,to=te(()=>{"use strict";aa();oa();Js();Vs();Or=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),Zs=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"),Y_=BigInt(0),ya=BigInt(1),Qs=BigInt(2),X_=BigInt(3),ga=BigInt(5),Ra=BigInt(8);eo=pn(Or,void 0,!0),ba={a:eo.create(BigInt(-1)),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:eo,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:Ra,Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:Fs,randomBytes:Ms,adjustScalarBytes:Sa,uvRatio:Ea},yt=Xs(ba)});var ro=pt((Q_,no)=>{"use strict";var gn=fa().Buffer;function Aa(r){if(r.length>=255)throw new TypeError("Alphabet too long");for(var e=new Uint8Array(256),t=0;t<e.length;t++)e[t]=255;for(var n=0;n<r.length;n++){var s=r.charAt(n),o=s.charCodeAt(0);if(e[o]!==255)throw new TypeError(s+" is ambiguous");e[o]=n}var i=r.length,a=r.charAt(0),c=Math.log(i)/Math.log(256),l=Math.log(256)/Math.log(i);function d(p){if((Array.isArray(p)||p instanceof Uint8Array)&&(p=gn.from(p)),!gn.isBuffer(p))throw new TypeError("Expected Buffer");if(p.length===0)return"";for(var g=0,R=0,S=0,N=p.length;S!==N&&p[S]===0;)S++,g++;for(var M=(N-S)*l+1>>>0,Z=new Uint8Array(M);S!==N;){for(var v=p[S],pe=0,Le=M-1;(v!==0||pe<R)&&Le!==-1;Le--,pe++)v+=256*Z[Le]>>>0,Z[Le]=v%i>>>0,v=v/i>>>0;if(v!==0)throw new Error("Non-zero carry");R=pe,S++}for(var ue=M-R;ue!==M&&Z[ue]===0;)ue++;for(var Qe=a.repeat(g);ue<M;++ue)Qe+=r.charAt(Z[ue]);return Qe}function _(p){if(typeof p!="string")throw new TypeError("Expected String");if(p.length===0)return gn.alloc(0);for(var g=0,R=0,S=0;p[g]===a;)R++,g++;for(var N=(p.length-g)*c+1>>>0,M=new Uint8Array(N);g<p.length;){var Z=p.charCodeAt(g);if(Z>255)return;var v=e[Z];if(v===255)return;for(var pe=0,Le=N-1;(v!==0||pe<S)&&Le!==-1;Le--,pe++)v+=i*M[Le]>>>0,M[Le]=v%256>>>0,v=v/256>>>0;if(v!==0)throw new Error("Non-zero carry");S=pe,g++}for(var ue=N-S;ue!==N&&M[ue]===0;)ue++;var Qe=gn.allocUnsafe(R+(N-ue));Qe.fill(0,0,R);for(var ln=R;ue!==N;)Qe[ln++]=M[ue++];return Qe}function I(p){var g=_(p);if(g)return g;throw new Error("Non-base"+i+" character")}return{encode:d,decodeUnsafe:_,decode:I}}no.exports=Aa});var kr=pt((ep,so)=>{"use strict";var Ia=ro(),wa="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";so.exports=Ia(wa)});var oo={};gr(oo,{TextDecoder:()=>Sn,TextEncoder:()=>En});function tt(r,e,t){return e<=r&&r<=t}function bn(r){if(r===void 0)return{};if(r===Object(r))return r;throw TypeError("Could not convert argument to dictionary")}function Oa(r){for(var e=String(r),t=e.length,n=0,s=[];n<t;){var o=e.charCodeAt(n);if(o<55296||o>57343)s.push(o);else if(56320<=o&&o<=57343)s.push(65533);else if(55296<=o&&o<=56319)if(n===t-1)s.push(65533);else{var i=r.charCodeAt(n+1);if(56320<=i&&i<=57343){var a=o&1023,c=i&1023;s.push(65536+(a<<10)+c),n+=1}else s.push(65533)}n+=1}return s}function ka(r){for(var e="",t=0;t<r.length;++t){var n=r[t];n<=65535?e+=String.fromCharCode(n):(n-=65536,e+=String.fromCharCode((n>>10)+55296,(n&1023)+56320))}return e}function Tr(r){this.tokens=[].slice.call(r)}function Nr(r,e){if(r)throw TypeError("Decoder error");return e||65533}function Na(){}function Ta(){}function Sn(r,e){if(!(this instanceof Sn))return new Sn(r,e);if(r=r!==void 0?String(r).toLowerCase():mn,r!==mn)throw new Error("Encoding not supported. Only utf-8 is supported");e=bn(e),this._streaming=!1,this._BOMseen=!1,this._decoder=null,this._fatal=!!e.fatal,this._ignoreBOM=!!e.ignoreBOM,Object.defineProperty(this,"encoding",{value:"utf-8"}),Object.defineProperty(this,"fatal",{value:this._fatal}),Object.defineProperty(this,"ignoreBOM",{value:this._ignoreBOM})}function En(r,e){if(!(this instanceof En))return new En(r,e);if(r=r!==void 0?String(r).toLowerCase():mn,r!==mn)throw new Error("Encoding not supported. Only utf-8 is supported");e=bn(e),this._streaming=!1,this._encoder=null,this._options={fatal:!!e.fatal},Object.defineProperty(this,"encoding",{value:"utf-8"})}function La(r){var e=r.fatal,t=0,n=0,s=0,o=128,i=191;this.handler=function(a,c){if(c===Rn&&s!==0)return s=0,Nr(e);if(c===Rn)return Tt;if(s===0){if(tt(c,0,127))return c;if(tt(c,194,223))s=1,t=c-192;else if(tt(c,224,239))c===224&&(o=160),c===237&&(i=159),s=2,t=c-224;else if(tt(c,240,244))c===240&&(o=144),c===244&&(i=143),s=3,t=c-240;else return Nr(e);return t=t<<6*s,null}if(!tt(c,o,i))return t=s=n=0,o=128,i=191,a.prepend(c),Nr(e);if(o=128,i=191,n+=1,t+=c-128<<6*(s-n),n!==s)return null;var l=t;return t=s=n=0,l}}function va(r){var e=r.fatal;this.handler=function(t,n){if(n===Rn)return Tt;if(tt(n,0,127))return n;var s,o;tt(n,128,2047)?(s=1,o=192):tt(n,2048,65535)?(s=2,o=224):tt(n,65536,1114111)&&(s=3,o=240);for(var i=[(n>>6*s)+o];s>0;){var a=n>>6*(s-1);i.push(128|a&63),s-=1}return i}}var Rn,Tt,mn,io=te(()=>{"use strict";Rn=-1;Tr.prototype={endOfStream:function(){return!this.tokens.length},read:function(){return this.tokens.length?this.tokens.shift():Rn},prepend:function(r){if(Array.isArray(r))for(var e=r;e.length;)this.tokens.unshift(e.pop());else this.tokens.unshift(r)},push:function(r){if(Array.isArray(r))for(var e=r;e.length;)this.tokens.push(e.shift());else this.tokens.push(r)}};Tt=-1;Na.prototype={handler:function(r,e){}};Ta.prototype={handler:function(r,e){}};mn="utf-8";Sn.prototype={decode:function(e,t){var n;typeof e=="object"&&e instanceof ArrayBuffer?n=new Uint8Array(e):typeof e=="object"&&"buffer"in e&&e.buffer instanceof ArrayBuffer?n=new Uint8Array(e.buffer,e.byteOffset,e.byteLength):n=new Uint8Array(0),t=bn(t),this._streaming||(this._decoder=new La({fatal:this._fatal}),this._BOMseen=!1),this._streaming=!!t.stream;for(var s=new Tr(n),o=[],i;!s.endOfStream()&&(i=this._decoder.handler(s,s.read()),i!==Tt);)i!==null&&(Array.isArray(i)?o.push.apply(o,i):o.push(i));if(!this._streaming){do{if(i=this._decoder.handler(s,s.read()),i===Tt)break;i!==null&&(Array.isArray(i)?o.push.apply(o,i):o.push(i))}while(!s.endOfStream());this._decoder=null}return o.length&&["utf-8"].indexOf(this.encoding)!==-1&&!this._ignoreBOM&&!this._BOMseen&&(o[0]===65279?(this._BOMseen=!0,o.shift()):this._BOMseen=!0),ka(o)}};En.prototype={encode:function(e,t){e=e?String(e):"",t=bn(t),this._streaming||(this._encoder=new va(this._options)),this._streaming=!!t.stream;for(var n=[],s=new Tr(Oa(e)),o;!s.endOfStream()&&(o=this._encoder.handler(s,s.read()),o!==Tt);)Array.isArray(o)?n.push.apply(n,o):n.push(o);if(!this._streaming){for(;o=this._encoder.handler(s,s.read()),o!==Tt;)Array.isArray(o)?n.push.apply(n,o):n.push(o);this._encoder=null}return new Uint8Array(n)}}});var fo=pt(J=>{"use strict";var Ca=J&&J.__createBinding||(Object.create?function(r,e,t,n){n===void 0&&(n=t),Object.defineProperty(r,n,{enumerable:!0,get:function(){return e[t]}})}:function(r,e,t,n){n===void 0&&(n=t),r[n]=e[t]}),Ba=J&&J.__setModuleDefault||(Object.create?function(r,e){Object.defineProperty(r,"default",{enumerable:!0,value:e})}:function(r,e){r.default=e}),Ge=J&&J.__decorate||function(r,e,t,n){var s=arguments.length,o=s<3?e:n===null?n=Object.getOwnPropertyDescriptor(e,t):n,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")o=Reflect.decorate(r,e,t,n);else for(var a=r.length-1;a>=0;a--)(i=r[a])&&(o=(s<3?i(o):s>3?i(e,t,o):i(e,t))||o);return s>3&&o&&Object.defineProperty(e,t,o),o},xa=J&&J.__importStar||function(r){if(r&&r.__esModule)return r;var e={};if(r!=null)for(var t in r)t!=="default"&&Object.hasOwnProperty.call(r,t)&&Ca(e,r,t);return Ba(e,r),e},ao=J&&J.__importDefault||function(r){return r&&r.__esModule?r:{default:r}};Object.defineProperty(J,"__esModule",{value:!0});J.deserializeUnchecked=J.deserialize=J.serialize=J.BinaryReader=J.BinaryWriter=J.BorshError=J.baseDecode=J.baseEncode=void 0;var it=ao(js()),co=ao(kr()),Pa=xa((io(),Rr(oo))),Da=typeof TextDecoder!="function"?Pa.TextDecoder:TextDecoder,Ua=new Da("utf-8",{fatal:!0});function za(r){return typeof r=="string"&&(r=Buffer.from(r,"utf8")),co.default.encode(Buffer.from(r))}J.baseEncode=za;function Ma(r){return Buffer.from(co.default.decode(r))}J.baseDecode=Ma;var Lr=1024,fe=class extends Error{constructor(e){super(e),this.fieldPath=[],this.originalMessage=e}addToFieldPath(e){this.fieldPath.splice(0,0,e),this.message=this.originalMessage+": "+this.fieldPath.join(".")}};J.BorshError=fe;var An=class{constructor(){this.buf=Buffer.alloc(Lr),this.length=0}maybeResize(){this.buf.length<16+this.length&&(this.buf=Buffer.concat([this.buf,Buffer.alloc(Lr)]))}writeU8(e){this.maybeResize(),this.buf.writeUInt8(e,this.length),this.length+=1}writeU16(e){this.maybeResize(),this.buf.writeUInt16LE(e,this.length),this.length+=2}writeU32(e){this.maybeResize(),this.buf.writeUInt32LE(e,this.length),this.length+=4}writeU64(e){this.maybeResize(),this.writeBuffer(Buffer.from(new it.default(e).toArray("le",8)))}writeU128(e){this.maybeResize(),this.writeBuffer(Buffer.from(new it.default(e).toArray("le",16)))}writeU256(e){this.maybeResize(),this.writeBuffer(Buffer.from(new it.default(e).toArray("le",32)))}writeU512(e){this.maybeResize(),this.writeBuffer(Buffer.from(new it.default(e).toArray("le",64)))}writeBuffer(e){this.buf=Buffer.concat([Buffer.from(this.buf.subarray(0,this.length)),e,Buffer.alloc(Lr)]),this.length+=e.length}writeString(e){this.maybeResize();let t=Buffer.from(e,"utf8");this.writeU32(t.length),this.writeBuffer(t)}writeFixedArray(e){this.writeBuffer(Buffer.from(e))}writeArray(e,t){this.maybeResize(),this.writeU32(e.length);for(let n of e)this.maybeResize(),t(n)}toArray(){return this.buf.subarray(0,this.length)}};J.BinaryWriter=An;function qe(r,e,t){let n=t.value;t.value=function(...s){try{return n.apply(this,s)}catch(o){if(o instanceof RangeError){let i=o.code;if(["ERR_BUFFER_OUT_OF_BOUNDS","ERR_OUT_OF_RANGE"].indexOf(i)>=0)throw new fe("Reached the end of buffer when deserializing")}throw o}}}var we=class{constructor(e){this.buf=e,this.offset=0}readU8(){let e=this.buf.readUInt8(this.offset);return this.offset+=1,e}readU16(){let e=this.buf.readUInt16LE(this.offset);return this.offset+=2,e}readU32(){let e=this.buf.readUInt32LE(this.offset);return this.offset+=4,e}readU64(){let e=this.readBuffer(8);return new it.default(e,"le")}readU128(){let e=this.readBuffer(16);return new it.default(e,"le")}readU256(){let e=this.readBuffer(32);return new it.default(e,"le")}readU512(){let e=this.readBuffer(64);return new it.default(e,"le")}readBuffer(e){if(this.offset+e>this.buf.length)throw new fe(`Expected buffer length ${e} isn't within bounds`);let t=this.buf.slice(this.offset,this.offset+e);return this.offset+=e,t}readString(){let e=this.readU32(),t=this.readBuffer(e);try{return Ua.decode(t)}catch(n){throw new fe(`Error decoding UTF-8 string: ${n}`)}}readFixedArray(e){return new Uint8Array(this.readBuffer(e))}readArray(e){let t=this.readU32(),n=Array();for(let s=0;s<t;++s)n.push(e());return n}};Ge([qe],we.prototype,"readU8",null);Ge([qe],we.prototype,"readU16",null);Ge([qe],we.prototype,"readU32",null);Ge([qe],we.prototype,"readU64",null);Ge([qe],we.prototype,"readU128",null);Ge([qe],we.prototype,"readU256",null);Ge([qe],we.prototype,"readU512",null);Ge([qe],we.prototype,"readString",null);Ge([qe],we.prototype,"readFixedArray",null);Ge([qe],we.prototype,"readArray",null);J.BinaryReader=we;function uo(r){return r.charAt(0).toUpperCase()+r.slice(1)}function gt(r,e,t,n,s){try{if(typeof n=="string")s[`write${uo(n)}`](t);else if(n instanceof Array)if(typeof n[0]=="number"){if(t.length!==n[0])throw new fe(`Expecting byte array of length ${n[0]}, but got ${t.length} bytes`);s.writeFixedArray(t)}else if(n.length===2&&typeof n[1]=="number"){if(t.length!==n[1])throw new fe(`Expecting byte array of length ${n[1]}, but got ${t.length} bytes`);for(let o=0;o<n[1];o++)gt(r,null,t[o],n[0],s)}else s.writeArray(t,o=>{gt(r,e,o,n[0],s)});else if(n.kind!==void 0)switch(n.kind){case"option":{t==null?s.writeU8(0):(s.writeU8(1),gt(r,e,t,n.type,s));break}case"map":{s.writeU32(t.size),t.forEach((o,i)=>{gt(r,e,i,n.key,s),gt(r,e,o,n.value,s)});break}default:throw new fe(`FieldType ${n} unrecognized`)}else lo(r,t,s)}catch(o){throw o instanceof fe&&o.addToFieldPath(e),o}}function lo(r,e,t){if(typeof e.borshSerialize=="function"){e.borshSerialize(t);return}let n=r.get(e.constructor);if(!n)throw new fe(`Class ${e.constructor.name} is missing in schema`);if(n.kind==="struct")n.fields.map(([s,o])=>{gt(r,s,e[s],o,t)});else if(n.kind==="enum"){let s=e[n.field];for(let o=0;o<n.values.length;++o){let[i,a]=n.values[o];if(i===s){t.writeU8(o),gt(r,i,e[i],a,t);break}}}else throw new fe(`Unexpected schema kind: ${n.kind} for ${e.constructor.name}`)}function Fa(r,e,t=An){let n=new t;return lo(r,e,n),n.toArray()}J.serialize=Fa;function Rt(r,e,t,n){try{if(typeof t=="string")return n[`read${uo(t)}`]();if(t instanceof Array){if(typeof t[0]=="number")return n.readFixedArray(t[0]);if(typeof t[1]=="number"){let s=[];for(let o=0;o<t[1];o++)s.push(Rt(r,null,t[0],n));return s}else return n.readArray(()=>Rt(r,e,t[0],n))}if(t.kind==="option")return n.readU8()?Rt(r,e,t.type,n):void 0;if(t.kind==="map"){let s=new Map,o=n.readU32();for(let i=0;i<o;i++){let a=Rt(r,e,t.key,n),c=Rt(r,e,t.value,n);s.set(a,c)}return s}return vr(r,t,n)}catch(s){throw s instanceof fe&&s.addToFieldPath(e),s}}function vr(r,e,t){if(typeof e.borshDeserialize=="function")return e.borshDeserialize(t);let n=r.get(e);if(!n)throw new fe(`Class ${e.name} is missing in schema`);if(n.kind==="struct"){let s={};for(let[o,i]of r.get(e).fields)s[o]=Rt(r,o,i,t);return new e(s)}if(n.kind==="enum"){let s=t.readU8();if(s>=n.values.length)throw new fe(`Enum index: ${s} is out of range`);let[o,i]=n.values[s],a=Rt(r,o,i,t);return new e({[o]:a})}throw new fe(`Unexpected schema kind: ${n.kind} for ${e.constructor.name}`)}function Ka(r,e,t,n=we){let s=new n(t),o=vr(r,e,s);if(s.offset<t.length)throw new fe(`Unexpected ${t.length-s.offset} bytes after deserialized data`);return o}J.deserialize=Ka;function Wa(r,e,t,n=we){let s=new n(t);return vr(r,e,s)}J.deserializeUnchecked=Wa});var Pr=pt(h=>{"use strict";Object.defineProperty(h,"__esModule",{value:!0});h.s16=h.s8=h.nu64be=h.u48be=h.u40be=h.u32be=h.u24be=h.u16be=h.nu64=h.u48=h.u40=h.u32=h.u24=h.u16=h.u8=h.offset=h.greedy=h.Constant=h.UTF8=h.CString=h.Blob=h.Boolean=h.BitField=h.BitStructure=h.VariantLayout=h.Union=h.UnionLayoutDiscriminator=h.UnionDiscriminator=h.Structure=h.Sequence=h.DoubleBE=h.Double=h.FloatBE=h.Float=h.NearInt64BE=h.NearInt64=h.NearUInt64BE=h.NearUInt64=h.IntBE=h.Int=h.UIntBE=h.UInt=h.OffsetLayout=h.GreedyCount=h.ExternalLayout=h.bindConstructorLayout=h.nameWithProperty=h.Layout=h.uint8ArrayToBuffer=h.checkUint8Array=void 0;h.constant=h.utf8=h.cstr=h.blob=h.unionLayoutDiscriminator=h.union=h.seq=h.bits=h.struct=h.f64be=h.f64=h.f32be=h.f32=h.ns64be=h.s48be=h.s40be=h.s32be=h.s24be=h.s16be=h.ns64=h.s48=h.s40=h.s32=h.s24=void 0;var Br=wr();function Ct(r){if(!(r instanceof Uint8Array))throw new TypeError("b must be a Uint8Array")}h.checkUint8Array=Ct;function G(r){return Ct(r),Br.Buffer.from(r.buffer,r.byteOffset,r.length)}h.uint8ArrayToBuffer=G;var H=class{constructor(e,t){if(!Number.isInteger(e))throw new TypeError("span must be an integer");this.span=e,this.property=t}makeDestinationObject(){return{}}getSpan(e,t){if(0>this.span)throw new RangeError("indeterminate span");return this.span}replicate(e){let t=Object.create(this.constructor.prototype);return Object.assign(t,this),t.property=e,t}fromArray(e){}};h.Layout=H;function xr(r,e){return e.property?r+"["+e.property+"]":r}h.nameWithProperty=xr;function $a(r,e){if(typeof r!="function")throw new TypeError("Class must be constructor");if(Object.prototype.hasOwnProperty.call(r,"layout_"))throw new Error("Class is already bound to a layout");if(!(e&&e instanceof H))throw new TypeError("layout must be a Layout");if(Object.prototype.hasOwnProperty.call(e,"boundConstructor_"))throw new Error("layout is already bound to a constructor");r.layout_=e,e.boundConstructor_=r,e.makeDestinationObject=()=>new r,Object.defineProperty(r.prototype,"encode",{value(t,n){return e.encode(this,t,n)},writable:!0}),Object.defineProperty(r,"decode",{value(t,n){return e.decode(t,n)},writable:!0})}h.bindConstructorLayout=$a;var ge=class extends H{isCount(){throw new Error("ExternalLayout is abstract")}};h.ExternalLayout=ge;var In=class extends ge{constructor(e=1,t){if(!Number.isInteger(e)||0>=e)throw new TypeError("elementSpan must be a (positive) integer");super(-1,t),this.elementSpan=e}isCount(){return!0}decode(e,t=0){Ct(e);let n=e.length-t;return Math.floor(n/this.elementSpan)}encode(e,t,n){return 0}};h.GreedyCount=In;var Wt=class extends ge{constructor(e,t=0,n){if(!(e instanceof H))throw new TypeError("layout must be a Layout");if(!Number.isInteger(t))throw new TypeError("offset must be integer or undefined");super(e.span,n||e.property),this.layout=e,this.offset=t}isCount(){return this.layout instanceof ke||this.layout instanceof Ce}decode(e,t=0){return this.layout.decode(e,t+this.offset)}encode(e,t,n=0){return this.layout.encode(e,t,n+this.offset)}};h.OffsetLayout=Wt;var ke=class extends H{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return G(e).readUIntLE(t,this.span)}encode(e,t,n=0){return G(t).writeUIntLE(e,n,this.span),this.span}};h.UInt=ke;var Ce=class extends H{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return G(e).readUIntBE(t,this.span)}encode(e,t,n=0){return G(t).writeUIntBE(e,n,this.span),this.span}};h.UIntBE=Ce;var nt=class extends H{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return G(e).readIntLE(t,this.span)}encode(e,t,n=0){return G(t).writeIntLE(e,n,this.span),this.span}};h.Int=nt;var at=class extends H{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return G(e).readIntBE(t,this.span)}encode(e,t,n=0){return G(t).writeIntBE(e,n,this.span),this.span}};h.IntBE=at;var Cr=Math.pow(2,32);function Kn(r){let e=Math.floor(r/Cr),t=r-e*Cr;return{hi32:e,lo32:t}}function Wn(r,e){return r*Cr+e}var wn=class extends H{constructor(e){super(8,e)}decode(e,t=0){let n=G(e),s=n.readUInt32LE(t),o=n.readUInt32LE(t+4);return Wn(o,s)}encode(e,t,n=0){let s=Kn(e),o=G(t);return o.writeUInt32LE(s.lo32,n),o.writeUInt32LE(s.hi32,n+4),8}};h.NearUInt64=wn;var On=class extends H{constructor(e){super(8,e)}decode(e,t=0){let n=G(e),s=n.readUInt32BE(t),o=n.readUInt32BE(t+4);return Wn(s,o)}encode(e,t,n=0){let s=Kn(e),o=G(t);return o.writeUInt32BE(s.hi32,n),o.writeUInt32BE(s.lo32,n+4),8}};h.NearUInt64BE=On;var kn=class extends H{constructor(e){super(8,e)}decode(e,t=0){let n=G(e),s=n.readUInt32LE(t),o=n.readInt32LE(t+4);return Wn(o,s)}encode(e,t,n=0){let s=Kn(e),o=G(t);return o.writeUInt32LE(s.lo32,n),o.writeInt32LE(s.hi32,n+4),8}};h.NearInt64=kn;var Nn=class extends H{constructor(e){super(8,e)}decode(e,t=0){let n=G(e),s=n.readInt32BE(t),o=n.readUInt32BE(t+4);return Wn(s,o)}encode(e,t,n=0){let s=Kn(e),o=G(t);return o.writeInt32BE(s.hi32,n),o.writeUInt32BE(s.lo32,n+4),8}};h.NearInt64BE=Nn;var Tn=class extends H{constructor(e){super(4,e)}decode(e,t=0){return G(e).readFloatLE(t)}encode(e,t,n=0){return G(t).writeFloatLE(e,n),4}};h.Float=Tn;var Ln=class extends H{constructor(e){super(4,e)}decode(e,t=0){return G(e).readFloatBE(t)}encode(e,t,n=0){return G(t).writeFloatBE(e,n),4}};h.FloatBE=Ln;var vn=class extends H{constructor(e){super(8,e)}decode(e,t=0){return G(e).readDoubleLE(t)}encode(e,t,n=0){return G(t).writeDoubleLE(e,n),8}};h.Double=vn;var Cn=class extends H{constructor(e){super(8,e)}decode(e,t=0){return G(e).readDoubleBE(t)}encode(e,t,n=0){return G(t).writeDoubleBE(e,n),8}};h.DoubleBE=Cn;var Bn=class extends H{constructor(e,t,n){if(!(e instanceof H))throw new TypeError("elementLayout must be a Layout");if(!(t instanceof ge&&t.isCount()||Number.isInteger(t)&&0<=t))throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");let s=-1;!(t instanceof ge)&&0<e.span&&(s=t*e.span),super(s,n),this.elementLayout=e,this.count=t}getSpan(e,t=0){if(0<=this.span)return this.span;let n=0,s=this.count;if(s instanceof ge&&(s=s.decode(e,t)),0<this.elementLayout.span)n=s*this.elementLayout.span;else{let o=0;for(;o<s;)n+=this.elementLayout.getSpan(e,t+n),++o}return n}decode(e,t=0){let n=[],s=0,o=this.count;for(o instanceof ge&&(o=o.decode(e,t));s<o;)n.push(this.elementLayout.decode(e,t)),t+=this.elementLayout.getSpan(e,t),s+=1;return n}encode(e,t,n=0){let s=this.elementLayout,o=e.reduce((i,a)=>i+s.encode(a,t,n+i),0);return this.count instanceof ge&&this.count.encode(e.length,t,n),o}};h.Sequence=Bn;var xn=class extends H{constructor(e,t,n){if(!(Array.isArray(e)&&e.reduce((o,i)=>o&&i instanceof H,!0)))throw new TypeError("fields must be array of Layout instances");typeof t=="boolean"&&n===void 0&&(n=t,t=void 0);for(let o of e)if(0>o.span&&o.property===void 0)throw new Error("fields cannot contain unnamed variable-length layout");let s=-1;try{s=e.reduce((o,i)=>o+i.getSpan(),0)}catch{}super(s,t),this.fields=e,this.decodePrefixes=!!n}getSpan(e,t=0){if(0<=this.span)return this.span;let n=0;try{n=this.fields.reduce((s,o)=>{let i=o.getSpan(e,t);return t+=i,s+i},0)}catch{throw new RangeError("indeterminate span")}return n}decode(e,t=0){Ct(e);let n=this.makeDestinationObject();for(let s of this.fields)if(s.property!==void 0&&(n[s.property]=s.decode(e,t)),t+=s.getSpan(e,t),this.decodePrefixes&&e.length===t)break;return n}encode(e,t,n=0){let s=n,o=0,i=0;for(let a of this.fields){let c=a.span;if(i=0<c?c:0,a.property!==void 0){let l=e[a.property];l!==void 0&&(i=a.encode(l,t,n),0>c&&(c=a.getSpan(t,n)))}o=n,n+=c}return o+i-s}fromArray(e){let t=this.makeDestinationObject();for(let n of this.fields)n.property!==void 0&&0<e.length&&(t[n.property]=e.shift());return t}layoutFor(e){if(typeof e!="string")throw new TypeError("property must be string");for(let t of this.fields)if(t.property===e)return t}offsetOf(e){if(typeof e!="string")throw new TypeError("property must be string");let t=0;for(let n of this.fields){if(n.property===e)return t;0>n.span?t=-1:0<=t&&(t+=n.span)}}};h.Structure=xn;var $t=class{constructor(e){this.property=e}decode(e,t){throw new Error("UnionDiscriminator is abstract")}encode(e,t,n){throw new Error("UnionDiscriminator is abstract")}};h.UnionDiscriminator=$t;var vt=class extends $t{constructor(e,t){if(!(e instanceof ge&&e.isCount()))throw new TypeError("layout must be an unsigned integer ExternalLayout");super(t||e.property||"variant"),this.layout=e}decode(e,t){return this.layout.decode(e,t)}encode(e,t,n){return this.layout.encode(e,t,n)}};h.UnionLayoutDiscriminator=vt;var Vt=class extends H{constructor(e,t,n){let s;if(e instanceof ke||e instanceof Ce)s=new vt(new Wt(e));else if(e instanceof ge&&e.isCount())s=new vt(e);else if(e instanceof $t)s=e;else throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");if(t===void 0&&(t=null),!(t===null||t instanceof H))throw new TypeError("defaultLayout must be null or a Layout");if(t!==null){if(0>t.span)throw new Error("defaultLayout must have constant span");t.property===void 0&&(t=t.replicate("content"))}let o=-1;t&&(o=t.span,0<=o&&(e instanceof ke||e instanceof Ce)&&(o+=s.layout.span)),super(o,n),this.discriminator=s,this.usesPrefixDiscriminator=e instanceof ke||e instanceof Ce,this.defaultLayout=t,this.registry={};let i=this.defaultGetSourceVariant.bind(this);this.getSourceVariant=function(a){return i(a)},this.configGetSourceVariant=function(a){i=a.bind(this)}}getSpan(e,t=0){if(0<=this.span)return this.span;let n=this.getVariant(e,t);if(!n)throw new Error("unable to determine span for unrecognized variant");return n.getSpan(e,t)}defaultGetSourceVariant(e){if(Object.prototype.hasOwnProperty.call(e,this.discriminator.property)){if(this.defaultLayout&&this.defaultLayout.property&&Object.prototype.hasOwnProperty.call(e,this.defaultLayout.property))return;let t=this.registry[e[this.discriminator.property]];if(t&&(!t.layout||t.property&&Object.prototype.hasOwnProperty.call(e,t.property)))return t}else for(let t in this.registry){let n=this.registry[t];if(n.property&&Object.prototype.hasOwnProperty.call(e,n.property))return n}throw new Error("unable to infer src variant")}decode(e,t=0){let n,s=this.discriminator,o=s.decode(e,t),i=this.registry[o];if(i===void 0){let a=this.defaultLayout,c=0;this.usesPrefixDiscriminator&&(c=s.layout.span),n=this.makeDestinationObject(),n[s.property]=o,n[a.property]=a.decode(e,t+c)}else n=i.decode(e,t);return n}encode(e,t,n=0){let s=this.getSourceVariant(e);if(s===void 0){let o=this.discriminator,i=this.defaultLayout,a=0;return this.usesPrefixDiscriminator&&(a=o.layout.span),o.encode(e[o.property],t,n),a+i.encode(e[i.property],t,n+a)}return s.encode(e,t,n)}addVariant(e,t,n){let s=new Pn(this,e,t,n);return this.registry[e]=s,s}getVariant(e,t=0){let n;return e instanceof Uint8Array?n=this.discriminator.decode(e,t):n=e,this.registry[n]}};h.Union=Vt;var Pn=class extends H{constructor(e,t,n,s){if(!(e instanceof Vt))throw new TypeError("union must be a Union");if(!Number.isInteger(t)||0>t)throw new TypeError("variant must be a (non-negative) integer");if(typeof n=="string"&&s===void 0&&(s=n,n=null),n){if(!(n instanceof H))throw new TypeError("layout must be a Layout");if(e.defaultLayout!==null&&0<=n.span&&n.span>e.defaultLayout.span)throw new Error("variant span exceeds span of containing union");if(typeof s!="string")throw new TypeError("variant must have a String property")}let o=e.span;0>e.span&&(o=n?n.span:0,0<=o&&e.usesPrefixDiscriminator&&(o+=e.discriminator.layout.span)),super(o,s),this.union=e,this.variant=t,this.layout=n||null}getSpan(e,t=0){if(0<=this.span)return this.span;let n=0;this.union.usesPrefixDiscriminator&&(n=this.union.discriminator.layout.span);let s=0;return this.layout&&(s=this.layout.getSpan(e,t+n)),n+s}decode(e,t=0){let n=this.makeDestinationObject();if(this!==this.union.getVariant(e,t))throw new Error("variant mismatch");let s=0;return this.union.usesPrefixDiscriminator&&(s=this.union.discriminator.layout.span),this.layout?n[this.property]=this.layout.decode(e,t+s):this.property?n[this.property]=!0:this.union.usesPrefixDiscriminator&&(n[this.union.discriminator.property]=this.variant),n}encode(e,t,n=0){let s=0;if(this.union.usesPrefixDiscriminator&&(s=this.union.discriminator.layout.span),this.layout&&!Object.prototype.hasOwnProperty.call(e,this.property))throw new TypeError("variant lacks property "+this.property);this.union.discriminator.encode(this.variant,t,n);let o=s;if(this.layout&&(this.layout.encode(e[this.property],t,n+s),o+=this.layout.getSpan(t,n+s),0<=this.union.span&&o>this.union.span))throw new Error("encoded variant overruns containing union");return o}fromArray(e){if(this.layout)return this.layout.fromArray(e)}};h.VariantLayout=Pn;function Lt(r){return 0>r&&(r+=4294967296),r}var Gt=class extends H{constructor(e,t,n){if(!(e instanceof ke||e instanceof Ce))throw new TypeError("word must be a UInt or UIntBE layout");if(typeof t=="string"&&n===void 0&&(n=t,t=!1),4<e.span)throw new RangeError("word cannot exceed 32 bits");super(e.span,n),this.word=e,this.msb=!!t,this.fields=[];let s=0;this._packedSetValue=function(o){return s=Lt(o),this},this._packedGetValue=function(){return s}}decode(e,t=0){let n=this.makeDestinationObject(),s=this.word.decode(e,t);this._packedSetValue(s);for(let o of this.fields)o.property!==void 0&&(n[o.property]=o.decode(e));return n}encode(e,t,n=0){let s=this.word.decode(t,n);this._packedSetValue(s);for(let o of this.fields)if(o.property!==void 0){let i=e[o.property];i!==void 0&&o.encode(i)}return this.word.encode(this._packedGetValue(),t,n)}addField(e,t){let n=new qt(this,e,t);return this.fields.push(n),n}addBoolean(e){let t=new Dn(this,e);return this.fields.push(t),t}fieldFor(e){if(typeof e!="string")throw new TypeError("property must be string");for(let t of this.fields)if(t.property===e)return t}};h.BitStructure=Gt;var qt=class{constructor(e,t,n){if(!(e instanceof Gt))throw new TypeError("container must be a BitStructure");if(!Number.isInteger(t)||0>=t)throw new TypeError("bits must be positive integer");let s=8*e.span,o=e.fields.reduce((i,a)=>i+a.bits,0);if(t+o>s)throw new Error("bits too long for span remainder ("+(s-o)+" of "+s+" remain)");this.container=e,this.bits=t,this.valueMask=(1<<t)-1,t===32&&(this.valueMask=4294967295),this.start=o,this.container.msb&&(this.start=s-o-t),this.wordMask=Lt(this.valueMask<<this.start),this.property=n}decode(e,t){let n=this.container._packedGetValue();return Lt(n&this.wordMask)>>>this.start}encode(e){if(typeof e!="number"||!Number.isInteger(e)||e!==Lt(e&this.valueMask))throw new TypeError(xr("BitField.encode",this)+" value must be integer not exceeding "+this.valueMask);let t=this.container._packedGetValue(),n=Lt(e<<this.start);this.container._packedSetValue(Lt(t&~this.wordMask)|n)}};h.BitField=qt;var Dn=class extends qt{constructor(e,t){super(e,1,t)}decode(e,t){return!!super.decode(e,t)}encode(e){typeof e=="boolean"&&(e=+e),super.encode(e)}};h.Boolean=Dn;var Un=class extends H{constructor(e,t){if(!(e instanceof ge&&e.isCount()||Number.isInteger(e)&&0<=e))throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");let n=-1;e instanceof ge||(n=e),super(n,t),this.length=e}getSpan(e,t){let n=this.span;return 0>n&&(n=this.length.decode(e,t)),n}decode(e,t=0){let n=this.span;return 0>n&&(n=this.length.decode(e,t)),G(e).slice(t,t+n)}encode(e,t,n){let s=this.length;if(this.length instanceof ge&&(s=e.length),!(e instanceof Uint8Array&&s===e.length))throw new TypeError(xr("Blob.encode",this)+" requires (length "+s+") Uint8Array as src");if(n+s>t.length)throw new RangeError("encoding overruns Uint8Array");let o=G(e);return G(t).write(o.toString("hex"),n,s,"hex"),this.length instanceof ge&&this.length.encode(s,t,n),s}};h.Blob=Un;var zn=class extends H{constructor(e){super(-1,e)}getSpan(e,t=0){Ct(e);let n=t;for(;n<e.length&&e[n]!==0;)n+=1;return 1+n-t}decode(e,t=0){let n=this.getSpan(e,t);return G(e).slice(t,t+n-1).toString("utf-8")}encode(e,t,n=0){typeof e!="string"&&(e=String(e));let s=Br.Buffer.from(e,"utf8"),o=s.length;if(n+o>t.length)throw new RangeError("encoding overruns Buffer");let i=G(t);return s.copy(i,n),i[n+o]=0,o+1}};h.CString=zn;var Mn=class extends H{constructor(e,t){if(typeof e=="string"&&t===void 0&&(t=e,e=void 0),e===void 0)e=-1;else if(!Number.isInteger(e))throw new TypeError("maxSpan must be an integer");super(-1,t),this.maxSpan=e}getSpan(e,t=0){return Ct(e),e.length-t}decode(e,t=0){let n=this.getSpan(e,t);if(0<=this.maxSpan&&this.maxSpan<n)throw new RangeError("text length exceeds maxSpan");return G(e).slice(t,t+n).toString("utf-8")}encode(e,t,n=0){typeof e!="string"&&(e=String(e));let s=Br.Buffer.from(e,"utf8"),o=s.length;if(0<=this.maxSpan&&this.maxSpan<o)throw new RangeError("text length exceeds maxSpan");if(n+o>t.length)throw new RangeError("encoding overruns Buffer");return s.copy(G(t),n),o}};h.UTF8=Mn;var Fn=class extends H{constructor(e,t){super(0,t),this.value=e}decode(e,t){return this.value}encode(e,t,n){return 0}};h.Constant=Fn;h.greedy=(r,e)=>new In(r,e);h.offset=(r,e,t)=>new Wt(r,e,t);h.u8=r=>new ke(1,r);h.u16=r=>new ke(2,r);h.u24=r=>new ke(3,r);h.u32=r=>new ke(4,r);h.u40=r=>new ke(5,r);h.u48=r=>new ke(6,r);h.nu64=r=>new wn(r);h.u16be=r=>new Ce(2,r);h.u24be=r=>new Ce(3,r);h.u32be=r=>new Ce(4,r);h.u40be=r=>new Ce(5,r);h.u48be=r=>new Ce(6,r);h.nu64be=r=>new On(r);h.s8=r=>new nt(1,r);h.s16=r=>new nt(2,r);h.s24=r=>new nt(3,r);h.s32=r=>new nt(4,r);h.s40=r=>new nt(5,r);h.s48=r=>new nt(6,r);h.ns64=r=>new kn(r);h.s16be=r=>new at(2,r);h.s24be=r=>new at(3,r);h.s32be=r=>new at(4,r);h.s40be=r=>new at(5,r);h.s48be=r=>new at(6,r);h.ns64be=r=>new Nn(r);h.f32=r=>new Tn(r);h.f32be=r=>new Ln(r);h.f64=r=>new vn(r);h.f64be=r=>new Cn(r);h.struct=(r,e,t)=>new xn(r,e,t);h.bits=(r,e,t)=>new Gt(r,e,t);h.seq=(r,e,t)=>new Bn(r,e,t);h.union=(r,e,t)=>new Vt(r,e,t);h.unionLayoutDiscriminator=(r,e)=>new vt(r,e);h.blob=(r,e)=>new Un(r,e);h.cstr=r=>new zn(r);h.utf8=(r,e)=>new Mn(r,e);h.constant=(r,e)=>new Fn(r,e)});function mo(r){return Array.isArray(r)?"%5B"+r.map(mo).join("%2C%20")+"%5D":typeof r=="bigint"?`${r}n`:encodeURIComponent(String(r!=null&&Object.getPrototypeOf(r)===null?C({},r):r))}function Kl([r,e]){return`${r}=${mo(e)}`}function Wl(r){let e=Object.entries(r).map(Kl).join("&");return btoa(e)}function $l(r,e={}){{let t=`Solana error #${r}; Decode this error by running \`npx @solana/errors decode -- ${r}`;return Object.keys(e).length&&(t+=` '${Wl(e)}'`),`${t}\``}}var Va,Ga,qa,Ha,ja,Ya,Xa,Ja,Za,Qa,ec,tc,nc,rc,sc,oc,ic,ac,cc,uc,dc,lc,fc,hc,_c,pc,yc,gc,Rc,mc,Sc,Ec,bc,Ac,Ic,wc,Oc,kc,Nc,Tc,Lc,vc,Cc,Bc,xc,Pc,Dc,Uc,zc,Mc,Fc,Kc,Wc,$c,Vc,Gc,qc,Hc,jc,Yc,Xc,Jc,Zc,Qc,eu,tu,nu,ru,su,ou,iu,au,cu,uu,du,lu,fu,hu,_u,pu,yu,gu,Ru,mu,Su,Eu,bu,Au,Iu,wu,Ou,ku,Nu,Tu,Lu,vu,Cu,Bu,xu,Pu,Du,Uu,zu,Mu,Fu,Ku,Wu,$u,Vu,Gu,qu,Hu,ju,Yu,Xu,Ju,Zu,Qu,ed,td,nd,rd,sd,od,id,ad,cd,ud,dd,ld,fd,hd,_d,pd,yd,gd,Rd,md,Sd,Ed,bd,Ad,Id,wd,Od,kd,Nd,Td,Ld,vd,Cd,Bd,xd,Pd,Dd,Ud,zd,Md,Fd,Kd,Wd,$d,Vd,Gd,qd,Hd,jd,Yd,Xd,Jd,Zd,Qd,el,tl,nl,rl,sl,ol,il,al,cl,ul,dl,ll,fl,hl,_l,pl,Dr,Ur,ho,_o,zr,Mr,Fr,yl,gl,Rl,ml,Kr,Sl,po,yo,El,bl,Al,Il,wl,go,Ro,Ol,kl,Nl,Tl,Ll,vl,Cl,Bl,xl,Pl,Dl,Ul,zl,Ml,Fl,rp,ct,Wr=te(()=>{"use strict";Va=1,Ga=2,qa=3,Ha=4,ja=5,Ya=6,Xa=7,Ja=8,Za=9,Qa=10,ec=-32700,tc=-32603,nc=-32602,rc=-32601,sc=-32600,oc=-32016,ic=-32015,ac=-32014,cc=-32013,uc=-32012,dc=-32011,lc=-32010,fc=-32009,hc=-32008,_c=-32007,pc=-32006,yc=-32005,gc=-32004,Rc=-32003,mc=-32002,Sc=-32001,Ec=28e5,bc=2800001,Ac=2800002,Ic=2800003,wc=2800004,Oc=2800005,kc=2800006,Nc=2800007,Tc=2800008,Lc=2800009,vc=2800010,Cc=323e4,Bc=32300001,xc=3230002,Pc=3230003,Dc=3230004,Uc=361e4,zc=3610001,Mc=3610002,Fc=3610003,Kc=3610004,Wc=3610005,$c=3610006,Vc=3610007,Gc=3611e3,qc=3704e3,Hc=3704001,jc=3704002,Yc=3704003,Xc=3704004,Jc=4128e3,Zc=4128001,Qc=4128002,eu=4615e3,tu=4615001,nu=4615002,ru=4615003,su=4615004,ou=4615005,iu=4615006,au=4615007,cu=4615008,uu=4615009,du=4615010,lu=4615011,fu=4615012,hu=4615013,_u=4615014,pu=4615015,yu=4615016,gu=4615017,Ru=4615018,mu=4615019,Su=4615020,Eu=4615021,bu=4615022,Au=4615023,Iu=4615024,wu=4615025,Ou=4615026,ku=4615027,Nu=4615028,Tu=4615029,Lu=4615030,vu=4615031,Cu=4615032,Bu=4615033,xu=4615034,Pu=4615035,Du=4615036,Uu=4615037,zu=4615038,Mu=4615039,Fu=4615040,Ku=4615041,Wu=4615042,$u=4615043,Vu=4615044,Gu=4615045,qu=4615046,Hu=4615047,ju=4615048,Yu=4615049,Xu=4615050,Ju=4615051,Zu=4615052,Qu=4615053,ed=4615054,td=5508e3,nd=5508001,rd=5508002,sd=5508003,od=5508004,id=5508005,ad=5508006,cd=5508007,ud=5508008,dd=5508009,ld=5508010,fd=5508011,hd=5663e3,_d=5663001,pd=5663002,yd=5663003,gd=5663004,Rd=5663005,md=5663006,Sd=5663007,Ed=5663008,bd=5663009,Ad=5663010,Id=5663011,wd=5663012,Od=5663013,kd=5663014,Nd=5663015,Td=5663016,Ld=5663017,vd=5663018,Cd=5663019,Bd=705e4,xd=7050001,Pd=7050002,Dd=7050003,Ud=7050004,zd=7050005,Md=7050006,Fd=7050007,Kd=7050008,Wd=7050009,$d=7050010,Vd=7050011,Gd=7050012,qd=7050013,Hd=7050014,jd=7050015,Yd=7050016,Xd=7050017,Jd=7050018,Zd=7050019,Qd=7050020,el=7050021,tl=7050022,nl=7050023,rl=7050024,sl=7050025,ol=7050026,il=7050027,al=7050028,cl=7050029,ul=7050030,dl=7050031,ll=7050032,fl=7050033,hl=7050034,_l=7050035,pl=7050036,Dr=8078e3,Ur=8078001,ho=8078002,_o=8078003,zr=8078004,Mr=8078005,Fr=8078006,yl=8078007,gl=8078008,Rl=8078009,ml=8078010,Kr=8078011,Sl=8078012,po=8078013,yo=8078014,El=8078015,bl=8078016,Al=8078017,Il=8078018,wl=8078019,go=8078020,Ro=8078021,Ol=8078022,kl=81e5,Nl=8100001,Tl=8100002,Ll=8100003,vl=819e4,Cl=8190001,Bl=8190002,xl=8190003,Pl=8190004,Dl=99e5,Ul=9900001,zl=9900002,Ml=9900003,Fl=9900004;rp={[Cc]:"Account not found at address: $address",[Dc]:"Not all accounts were decoded. Encoded accounts found at addresses: $addresses.",[Pc]:"Expected decoded account at address: $address",[xc]:"Failed to decode account data at address: $address",[Bc]:"Accounts not found at addresses: $addresses",[Lc]:"Unable to find a viable program address bump seed.",[Ac]:"$putativeAddress is not a base58-encoded address.",[Ec]:"Expected base58 encoded address to decode to a byte array of length 32. Actual length: $actualLength.",[Ic]:"The `CryptoKey` must be an `Ed25519` public key.",[Tc]:"Invalid seeds; point must fall off the Ed25519 curve.",[wc]:"Expected given program derived address to have the following format: [Address, ProgramDerivedAddressBump].",[kc]:"A maximum of $maxSeeds seeds, including the bump seed, may be supplied when creating an address. Received: $actual.",[Nc]:"The seed at index $index with length $actual exceeds the maximum length of $maxSeedLength bytes.",[Oc]:"Expected program derived address bump to be in the range [0, 255], got: $bump.",[vc]:"Program address cannot end with PDA marker.",[bc]:"Expected base58-encoded address string of length in the range [32, 44]. Actual length: $actualLength.",[Ha]:"Expected base58-encoded blockash string of length in the range [32, 44]. Actual length: $actualLength.",[Va]:"The network has progressed past the last block for which this transaction could have been committed.",[Dr]:"Codec [$codecDescription] cannot decode empty byte arrays.",[Ol]:"Enum codec cannot use lexical values [$stringValues] as discriminators. Either remove all lexical values or set `useValuesAsDiscriminators` to `false`.",[go]:"Sentinel [$hexSentinel] must not be present in encoded bytes [$hexEncodedBytes].",[Mr]:"Encoder and decoder must have the same fixed size, got [$encoderFixedSize] and [$decoderFixedSize].",[Fr]:"Encoder and decoder must have the same max size, got [$encoderMaxSize] and [$decoderMaxSize].",[zr]:"Encoder and decoder must either both be fixed-size or variable-size.",[gl]:"Enum discriminator out of range. Expected a number in [$formattedValidDiscriminators], got $discriminator.",[ho]:"Expected a fixed-size codec, got a variable-size one.",[po]:"Codec [$codecDescription] expected a positive byte length, got $bytesLength.",[_o]:"Expected a variable-size codec, got a fixed-size one.",[wl]:"Codec [$codecDescription] expected zero-value [$hexZeroValue] to have the same size as the provided fixed-size item [$expectedSize bytes].",[Ur]:"Codec [$codecDescription] expected $expected bytes, got $bytesLength.",[Il]:"Expected byte array constant [$hexConstant] to be present in data [$hexData] at offset [$offset].",[Rl]:"Invalid discriminated union variant. Expected one of [$variants], got $value.",[ml]:"Invalid enum variant. Expected one of [$stringValues] or a number in [$formattedNumericalValues], got $variant.",[El]:"Invalid literal union variant. Expected one of [$variants], got $value.",[yl]:"Expected [$codecDescription] to have $expected items, got $actual.",[Sl]:"Invalid value $value for base $base with alphabet $alphabet.",[bl]:"Literal union discriminator out of range. Expected a number between $minRange and $maxRange, got $discriminator.",[Kr]:"Codec [$codecDescription] expected number to be in the range [$min, $max], got $value.",[yo]:"Codec [$codecDescription] expected offset to be in the range [0, $bytesLength], got $offset.",[Ro]:"Expected sentinel [$hexSentinel] to be present in decoded bytes [$hexDecodedBytes].",[Al]:"Union variant out of range. Expected an index between $minRange and $maxRange, got $variant.",[Gc]:"No random values implementation could be found.",[uu]:"instruction requires an uninitialized account",[Au]:"instruction tries to borrow reference for an account which is already borrowed",[Iu]:"instruction left account with an outstanding borrowed reference",[Eu]:"program other than the account's owner changed the size of the account data",[ou]:"account data too small for instruction",[bu]:"instruction expected an executable account",[qu]:"An account does not have enough lamports to be rent-exempt",[ju]:"Program arithmetic overflowed",[Gu]:"Failed to serialize or deserialize account data: $encodedData",[ed]:"Builtin programs must consume compute units",[Cu]:"Cross-program invocation call depth too deep",[zu]:"Computational budget exceeded",[Ou]:"custom program error: #$code",[gu]:"instruction contains duplicate accounts",[wu]:"instruction modifications of multiply-passed account differ",[Lu]:"executable accounts must be rent exempt",[Nu]:"instruction changed executable accounts data",[Tu]:"instruction changed the balance of an executable account",[Ru]:"instruction changed executable bit of an account",[_u]:"instruction modified data of an account it does not own",[hu]:"instruction spent from the balance of an account it does not own",[tu]:"generic instruction error",[Xu]:"Provided owner is not allowed",[$u]:"Account is immutable",[Vu]:"Incorrect authority provided",[au]:"incorrect program id for instruction",[iu]:"insufficient funds for instruction",[su]:"invalid account data for instruction",[Hu]:"Invalid account owner",[nu]:"invalid program argument",[ku]:"program returned invalid error code",[ru]:"invalid instruction data",[Uu]:"Failed to reallocate account data",[Du]:"Provided seeds do not result in a valid address",[Ju]:"Accounts data allocations exceeded the maximum allowed per transaction",[Zu]:"Max accounts exceeded",[Qu]:"Max instruction trace length exceeded",[Pu]:"Length of the seed is too long for address generation",[Bu]:"An account required by the instruction is missing",[cu]:"missing required signature for instruction",[fu]:"instruction illegally modified the program id of an account",[Su]:"insufficient account keys for instruction",[Mu]:"Cross-program invocation with unauthorized signer or writable account",[Fu]:"Failed to create program execution environment",[Wu]:"Program failed to compile",[Ku]:"Program failed to complete",[yu]:"instruction modified data of a read-only account",[pu]:"instruction changed the balance of a read-only account",[xu]:"Cross-program invocation reentrancy not allowed for this instruction",[mu]:"instruction modified rent epoch of an account",[lu]:"sum of account balances before and after instruction do not match",[du]:"instruction requires an initialized account",[eu]:"",[vu]:"Unsupported program id",[Yu]:"Unsupported sysvar",[Jc]:"The instruction does not have any accounts.",[Zc]:"The instruction does not have any data.",[Qc]:"Expected instruction to have progress address $expectedProgramAddress, got $actualProgramAddress.",[ja]:"Expected base58 encoded blockhash to decode to a byte array of length 32. Actual length: $actualLength.",[Ga]:"The nonce `$expectedNonceValue` is no longer valid. It has advanced to `$actualNonceValue`",[zl]:"Invariant violation: Found no abortable iterable cache entry for key `$cacheKey`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",[Fl]:"Invariant violation: This data publisher does not publish to the channel named `$channelName`. Supported channels include $supportedChannelNames.",[Ul]:"Invariant violation: WebSocket message iterator state is corrupt; iterated without first resolving existing message promise. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",[Dl]:"Invariant violation: WebSocket message iterator is missing state storage. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",[Ml]:"Invariant violation: Switch statement non-exhaustive. Received unexpected value `$unexpectedValue`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",[tc]:"JSON-RPC error: Internal JSON-RPC error ($__serverMessage)",[nc]:"JSON-RPC error: Invalid method parameter(s) ($__serverMessage)",[sc]:"JSON-RPC error: The JSON sent is not a valid `Request` object ($__serverMessage)",[rc]:"JSON-RPC error: The method does not exist / is not available ($__serverMessage)",[ec]:"JSON-RPC error: An error occurred on the server while parsing the JSON text ($__serverMessage)",[uc]:"$__serverMessage",[Sc]:"$__serverMessage",[gc]:"$__serverMessage",[ac]:"$__serverMessage",[lc]:"$__serverMessage",[fc]:"$__serverMessage",[oc]:"Minimum context slot has not been reached",[yc]:"Node is unhealthy; behind by $numSlotsBehind slots",[hc]:"No snapshot",[mc]:"Transaction simulation failed",[_c]:"$__serverMessage",[dc]:"Transaction history is not available from this node",[pc]:"$__serverMessage",[cc]:"Transaction signature length mismatch",[Rc]:"Transaction signature verification failure",[ic]:"$__serverMessage",[qc]:"Key pair bytes must be of length 64, got $byteLength.",[Hc]:"Expected private key bytes with length 32. Actual length: $actualLength.",[jc]:"Expected base58-encoded signature to decode to a byte array of length 64. Actual length: $actualLength.",[Xc]:"The provided private key does not match the provided public key.",[Yc]:"Expected base58-encoded signature string of length in the range [64, 88]. Actual length: $actualLength.",[Ya]:"Lamports value must be in the range [0, 2e64-1]",[Xa]:"`$value` cannot be parsed as a `BigInt`",[Qa]:"$message",[Ja]:"`$value` cannot be parsed as a `Number`",[qa]:"No nonce account could be found at address `$nonceAccountAddress`",[vl]:"The notification name must end in 'Notifications' and the API must supply a subscription plan creator function for the notification '$notificationName'.",[Bl]:"WebSocket was closed before payload could be added to the send buffer",[xl]:"WebSocket connection closed",[Pl]:"WebSocket failed to connect",[Cl]:"Failed to obtain a subscription id from the server",[Ll]:"Could not find an API plan for RPC method: `$method`",[kl]:"The $argumentLabel argument to the `$methodName` RPC method$optionalPathLabel was `$value`. This number is unsafe for use with the Solana JSON-RPC because it exceeds `Number.MAX_SAFE_INTEGER`.",[Tl]:"HTTP error ($statusCode): $message",[Nl]:"HTTP header(s) forbidden: $headers. Learn more at https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name.",[td]:"Multiple distinct signers were identified for address `$address`. Please ensure that you are using the same signer instance for each address.",[nd]:"The provided value does not implement the `KeyPairSigner` interface",[sd]:"The provided value does not implement the `MessageModifyingSigner` interface",[od]:"The provided value does not implement the `MessagePartialSigner` interface",[rd]:"The provided value does not implement any of the `MessageSigner` interfaces",[ad]:"The provided value does not implement the `TransactionModifyingSigner` interface",[cd]:"The provided value does not implement the `TransactionPartialSigner` interface",[ud]:"The provided value does not implement the `TransactionSendingSigner` interface",[id]:"The provided value does not implement any of the `TransactionSigner` interfaces",[dd]:"More than one `TransactionSendingSigner` was identified.",[ld]:"No `TransactionSendingSigner` was identified. Please provide a valid `ITransactionWithSingleSendingSigner` transaction.",[fd]:"Wallet account signers do not support signing multiple messages/transactions in a single operation",[Vc]:"Cannot export a non-extractable key.",[zc]:"No digest implementation could be found.",[Uc]:"Cryptographic operations are only allowed in secure browser contexts. Read more here: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts.",[Mc]:`This runtime does not support the generation of Ed25519 key pairs.

Install @solana/webcrypto-ed25519-polyfill and call its \`install\` function before generating keys in environments that do not support Ed25519.

For a list of runtimes that currently support Ed25519 operations, visit https://github.com/WICG/webcrypto-secure-curves/issues/20.`,[Fc]:"No signature verification implementation could be found.",[Kc]:"No key generation implementation could be found.",[Wc]:"No signing implementation could be found.",[$c]:"No key export implementation could be found.",[Za]:"Timestamp value must be in the range [-(2n ** 63n), (2n ** 63n) - 1]. `$value` given",[Yd]:"Transaction processing left an account with an outstanding borrowed reference",[xd]:"Account in use",[Pd]:"Account loaded twice",[Dd]:"Attempt to debit an account but found no record of a prior credit.",[nl]:"Transaction loads an address table account that doesn't exist",[Fd]:"This transaction has already been processed",[Kd]:"Blockhash not found",[Wd]:"Loader call chain is too deep",[jd]:"Transactions are currently disabled due to cluster maintenance",[ul]:"Transaction contains a duplicate instruction ($index) that is not allowed",[zd]:"Insufficient funds for fee",[dl]:"Transaction results in an account ($accountIndex) with insufficient funds for rent",[Md]:"This account may not be used to pay transaction fees",[Vd]:"Transaction contains an invalid account reference",[sl]:"Transaction loads an address table account with invalid data",[ol]:"Transaction address table lookup uses an invalid index",[rl]:"Transaction loads an address table account with an invalid owner",[fl]:"LoadedAccountsDataSizeLimit set for transaction must be greater than 0.",[qd]:"This program may not be used for executing instructions",[il]:"Transaction leaves an account with a lower balance than rent-exempt minimum",[Zd]:"Transaction loads a writable account that cannot be written",[ll]:"Transaction exceeded max loaded accounts data size cap",[$d]:"Transaction requires a fee but has no signature present",[Ud]:"Attempt to load a program that does not exist",[_l]:"Execution of the program referenced by account at index $accountIndex is temporarily restricted.",[hl]:"ResanitizationNeeded",[Hd]:"Transaction failed to sanitize accounts offsets correctly",[Gd]:"Transaction did not pass signature verification",[tl]:"Transaction locked too many accounts",[pl]:"Sum of account balances before and after transaction do not match",[Bd]:"The transaction failed with the error `$errorName`",[Jd]:"Transaction version is unsupported",[el]:"Transaction would exceed account data limit within the block",[cl]:"Transaction would exceed total account data limit",[Qd]:"Transaction would exceed max account limit within the block",[Xd]:"Transaction would exceed max Block Cost Limit",[al]:"Transaction would exceed max Vote Cost Limit",[Nd]:"Attempted to sign a transaction with an address that is not a signer for it",[Ad]:"Transaction is missing an address at index: $index.",[Td]:"Transaction has no expected signers therefore it cannot be encoded",[pd]:"Transaction does not have a blockhash lifetime",[yd]:"Transaction is not a durable nonce transaction",[Rd]:"Contents of these address lookup tables unknown: $lookupTableAddresses",[md]:"Lookup of address at index $highestRequestedIndex failed for lookup table `$lookupTableAddress`. Highest known index is $highestKnownIndex. The lookup table may have been extended since its contents were retrieved",[Ed]:"No fee payer set in CompiledTransaction",[Sd]:"Could not find program address at index $index",[vd]:"Failed to estimate the compute unit consumption for this transaction message. This is likely because simulating the transaction failed. Inspect the `cause` property of this error to learn more",[Cd]:"Transaction failed when it was simulated in order to estimate the compute unit consumption. The compute unit estimate provided is for a transaction that failed when simulated and may not be representative of the compute units this transaction would consume if successful. Inspect the `cause` property of this error to learn more",[Id]:"Transaction is missing a fee payer.",[wd]:"Could not determine this transaction's signature. Make sure that the transaction has been signed by its fee payer.",[kd]:"Transaction first instruction is not advance nonce account instruction.",[Od]:"Transaction with no instructions cannot be durable nonce transaction.",[hd]:"This transaction includes an address (`$programAddress`) which is both invoked and set as the fee payer. Program addresses may not pay fees",[_d]:"This transaction includes an address (`$programAddress`) which is both invoked and marked writable. Program addresses may not be writable",[Ld]:"The transaction message expected the transaction to have $signerAddressesLength signatures, got $signaturesLength.",[bd]:"Transaction is missing signatures for addresses: $addresses.",[gd]:"Transaction version must be in the range [0, 127]. `$actualVersion` given"};ct=class extends Error{cause=this.cause;context;constructor(...[r,e]){let t,n;if(e){let o=e,{cause:i}=o,a=De(o,["cause"]);i&&(n={cause:i}),Object.keys(a).length>0&&(t=a)}let s=$l(r,t);super(s,n),this.context=C({__code:r},t),this.name="SolanaError"}}});function Vl(r,e){return"fixedSize"in e?e.fixedSize:e.getSizeFromValue(r)}function So(r){return Object.freeze(F(C({},r),{encode:e=>{let t=new Uint8Array(Vl(e,r));return r.write(e,t,0),t}}))}function Eo(r){return Object.freeze(F(C({},r),{decode:(e,t=0)=>r.read(e,t)[0]}))}function Bt(r){return"fixedSize"in r&&typeof r.fixedSize=="number"}function bo(r,e){if(Bt(r)!==Bt(e))throw new ct(zr);if(Bt(r)&&Bt(e)&&r.fixedSize!==e.fixedSize)throw new ct(Mr,{decoderFixedSize:e.fixedSize,encoderFixedSize:r.fixedSize});if(!Bt(r)&&!Bt(e)&&r.maxSize!==e.maxSize)throw new ct(Fr,{decoderMaxSize:e.maxSize,encoderMaxSize:r.maxSize});return F(C(C({},e),r),{decode:e.decode,encode:r.encode,read:e.read,write:r.write})}function Ao(r,e,t=0){if(e.length-t<=0)throw new ct(Dr,{codecDescription:r})}function Io(r,e,t,n=0){let s=t.length-n;if(s<e)throw new ct(Ur,{bytesLength:s,codecDescription:r,expected:e})}var wo=te(()=>{"use strict";Wr()});function Gl(r,e,t,n){if(n<e||n>t)throw new ct(Kr,{codecDescription:r,max:t,min:e,value:n})}function Oo(r){return r?.endian!==1}function ql(r){return So({fixedSize:r.size,write(e,t,n){r.range&&Gl(r.name,r.range[0],r.range[1],e);let s=new ArrayBuffer(r.size);return r.set(new DataView(s),e,Oo(r.config)),t.set(new Uint8Array(s),n),n+r.size}})}function Hl(r){return Eo({fixedSize:r.size,read(e,t=0){Ao(r.name,e,t),Io(r.name,r.size,e,t);let n=new DataView(jl(e,t,r.size));return[r.get(n,Oo(r.config)),t+r.size]}})}function jl(r,e,t){let n=r.byteOffset+(e??0),s=t??r.byteLength;return r.buffer.slice(n,n+s)}var $r,Yl,ko,No=te(()=>{"use strict";Wr();wo();$r=(r={})=>ql({config:r,name:"u64",range:[0n,BigInt("0xffffffffffffffff")],set:(e,t,n)=>e.setBigUint64(0,BigInt(t),n),size:8}),Yl=(r={})=>Hl({config:r,get:(e,t)=>e.getBigUint64(0,t),name:"u64",size:8}),ko=(r={})=>bo($r(r),Yl(r))});function Xl(r){return Ht(r)&&typeof r[Symbol.iterator]=="function"}function Ht(r){return typeof r=="object"&&r!=null}function $n(r){return Ht(r)&&!Array.isArray(r)}function Me(r){return typeof r=="symbol"?r.toString():typeof r=="string"?JSON.stringify(r):`${r}`}function Jl(r){let{done:e,value:t}=r.next();return e?void 0:t}function Zl(r,e,t,n){if(r===!0)return;r===!1?r={}:typeof r=="string"&&(r={message:r});let{path:s,branch:o}=e,{type:i}=t,{refinement:a,message:c=`Expected a value of type \`${i}\`${a?` with refinement \`${a}\``:""}, but received: \`${Me(n)}\``}=r;return F(C({value:n,type:i,refinement:a,key:s[s.length-1],path:s,branch:o},r),{message:c})}function*To(r,e,t,n){Xl(r)||(r=[r]);for(let s of r){let o=Zl(s,e,t,n);o&&(yield o)}}function*Gr(r,e,t={}){let{path:n=[],branch:s=[r],coerce:o=!1,mask:i=!1}=t,a={path:n,branch:s,mask:i};o&&(r=e.coercer(r,a));let c="valid";for(let l of e.validator(r,a))l.explanation=t.message,c="not_valid",yield[l,void 0];for(let[l,d,_]of e.entries(r,a)){let I=Gr(d,_,{path:l===void 0?n:[...n,l],branch:l===void 0?s:[...s,d],coerce:o,mask:i,message:t.message});for(let p of I)p[0]?(c=p[0].refinement!=null?"not_refined":"not_valid",yield[p[0],void 0]):o&&(d=p[1],l===void 0?r=d:r instanceof Map?r.set(l,d):r instanceof Set?r.add(d):Ht(r)&&(d!==void 0||l in r)&&(r[l]=d))}if(c!=="not_valid")for(let l of e.refiner(r,a))l.explanation=t.message,c="not_refined",yield[l,void 0];c==="valid"&&(yield[void 0,r])}function qr(r,e,t){let n=jt(r,e,{message:t});if(n[0])throw n[0]}function A(r,e,t){let n=jt(r,e,{coerce:!0,message:t});if(n[0])throw n[0];return n[1]}function Ql(r,e,t){let n=jt(r,e,{coerce:!0,mask:!0,message:t});if(n[0])throw n[0];return n[1]}function Lo(r,e){return!jt(r,e)[0]}function jt(r,e,t={}){let n=Gr(r,e,t),s=Jl(n);return s[0]?[new Vr(s[0],function*(){for(let i of n)i[0]&&(yield i[0])}),void 0]:[void 0,s[1]]}function mt(r,e){return new Pe({type:r,schema:null,validator:e})}function vo(){return mt("any",()=>!0)}function O(r){return new Pe({type:"array",schema:r,*entries(e){if(r&&Array.isArray(e))for(let[t,n]of e.entries())yield[t,n,r]},coercer(e){return Array.isArray(e)?e.slice():e},validator(e){return Array.isArray(e)||`Expected an array value, but received: ${Me(e)}`}})}function Fe(){return mt("boolean",r=>typeof r=="boolean")}function Vn(r){return mt("instance",e=>e instanceof r||`Expected a \`${r.name}\` instance, but received: ${Me(e)}`)}function re(r){let e=Me(r),t=typeof r;return new Pe({type:"literal",schema:t==="string"||t==="number"||t==="boolean"?r:null,validator(n){return n===r||`Expected the literal \`${e}\`, but received: ${Me(n)}`}})}function ef(){return mt("never",()=>!1)}function k(r){return new Pe(F(C({},r),{validator:(e,t)=>e===null||r.validator(e,t),refiner:(e,t)=>e===null||r.refiner(e,t)}))}function f(){return mt("number",r=>typeof r=="number"&&!isNaN(r)||`Expected a number, but received: ${Me(r)}`)}function B(r){return new Pe(F(C({},r),{validator:(e,t)=>e===void 0||r.validator(e,t),refiner:(e,t)=>e===void 0||r.refiner(e,t)}))}function Hr(r,e){return new Pe({type:"record",schema:null,*entries(t){if(Ht(t))for(let n in t){let s=t[n];yield[n,n,r],yield[n,s,e]}},validator(t){return $n(t)||`Expected an object, but received: ${Me(t)}`},coercer(t){return $n(t)?C({},t):t}})}function E(){return mt("string",r=>typeof r=="string"||`Expected a string, but received: ${Me(r)}`)}function Gn(r){let e=ef();return new Pe({type:"tuple",schema:null,*entries(t){if(Array.isArray(t)){let n=Math.max(r.length,t.length);for(let s=0;s<n;s++)yield[s,t[s],r[s]||e]}},validator(t){return Array.isArray(t)||`Expected an array, but received: ${Me(t)}`},coercer(t){return Array.isArray(t)?t.slice():t}})}function m(r){let e=Object.keys(r);return new Pe({type:"type",schema:r,*entries(t){if(Ht(t))for(let n of e)yield[n,t[n],r[n]]},validator(t){return $n(t)||`Expected an object, but received: ${Me(t)}`},coercer(t){return $n(t)?C({},t):t}})}function Re(r){let e=r.map(t=>t.type).join(" | ");return new Pe({type:"union",schema:null,coercer(t,n){for(let s of r){let[o,i]=s.validate(t,{coerce:!0,mask:n.mask});if(!o)return i}return t},validator(t,n){let s=[];for(let o of r){let[...i]=Gr(t,o,n),[a]=i;if(a[0])for(let[c]of i)c&&s.push(c);else return[]}return[`Expected the value to satisfy a union of \`${e}\`, but received: ${Me(t)}`,...s]}})}function St(){return mt("unknown",()=>!0)}function xt(r,e,t){return new Pe(F(C({},r),{coercer:(n,s)=>Lo(n,e)?r.coercer(t(n,s),s):r.coercer(n,s)}))}var Vr,Pe,Co=te(()=>{"use strict";Vr=class extends TypeError{constructor(e,t){let n,l=e,{message:s,explanation:o}=l,i=De(l,["message","explanation"]),{path:a}=e,c=a.length===0?s:`At path: ${a.join(".")} -- ${s}`;super(o??c),o!=null&&(this.cause=c),Object.assign(this,i),this.name=this.constructor.name,this.failures=()=>n??(n=[e,...t()])}};Pe=class{constructor(e){let{type:t,schema:n,validator:s,refiner:o,coercer:i=c=>c,entries:a=function*(){}}=e;this.type=t,this.schema=n,this.entries=a,this.coercer=i,s?this.validator=(c,l)=>{let d=s(c,l);return To(d,l,this,c)}:this.validator=()=>[],o?this.refiner=(c,l)=>{let d=o(c,l);return To(d,l,this,c)}:this.refiner=()=>[]}assert(e,t){return qr(e,this,t)}create(e,t){return A(e,this,t)}is(e){return Lo(e,this)}mask(e,t){return Ql(e,this,t)}validate(e,t={}){return jt(e,this,t)}}});function Yt(){if(!qn&&(qn=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||typeof msCrypto<"u"&&typeof msCrypto.getRandomValues=="function"&&msCrypto.getRandomValues.bind(msCrypto),!qn))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return qn(tf)}var qn,tf,jr=te(()=>{"use strict";tf=new Uint8Array(16)});var Bo,xo=te(()=>{"use strict";Bo=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i});function nf(r){return typeof r=="string"&&Bo.test(r)}var ut,Xt=te(()=>{"use strict";xo();ut=nf});function rf(r){var e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0,t=(he[r[e+0]]+he[r[e+1]]+he[r[e+2]]+he[r[e+3]]+"-"+he[r[e+4]]+he[r[e+5]]+"-"+he[r[e+6]]+he[r[e+7]]+"-"+he[r[e+8]]+he[r[e+9]]+"-"+he[r[e+10]]+he[r[e+11]]+he[r[e+12]]+he[r[e+13]]+he[r[e+14]]+he[r[e+15]]).toLowerCase();if(!ut(t))throw TypeError("Stringified UUID is invalid");return t}var he,Hn,dt,Jt=te(()=>{"use strict";Xt();he=[];for(Hn=0;Hn<256;++Hn)he.push((Hn+256).toString(16).substr(1));dt=rf});function sf(r,e,t){var n=e&&t||0,s=e||new Array(16);r=r||{};var o=r.node||Po,i=r.clockseq!==void 0?r.clockseq:Yr;if(o==null||i==null){var a=r.random||(r.rng||Yt)();o==null&&(o=Po=[a[0]|1,a[1],a[2],a[3],a[4],a[5]]),i==null&&(i=Yr=(a[6]<<8|a[7])&16383)}var c=r.msecs!==void 0?r.msecs:Date.now(),l=r.nsecs!==void 0?r.nsecs:Jr+1,d=c-Xr+(l-Jr)/1e4;if(d<0&&r.clockseq===void 0&&(i=i+1&16383),(d<0||c>Xr)&&r.nsecs===void 0&&(l=0),l>=1e4)throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");Xr=c,Jr=l,Yr=i,c+=122192928e5;var _=((c&268435455)*1e4+l)%4294967296;s[n++]=_>>>24&255,s[n++]=_>>>16&255,s[n++]=_>>>8&255,s[n++]=_&255;var I=c/4294967296*1e4&268435455;s[n++]=I>>>8&255,s[n++]=I&255,s[n++]=I>>>24&15|16,s[n++]=I>>>16&255,s[n++]=i>>>8|128,s[n++]=i&255;for(var p=0;p<6;++p)s[n+p]=o[p];return e||dt(s)}var Po,Yr,Xr,Jr,Do,Uo=te(()=>{"use strict";jr();Jt();Xr=0,Jr=0;Do=sf});function of(r){if(!ut(r))throw TypeError("Invalid UUID");var e,t=new Uint8Array(16);return t[0]=(e=parseInt(r.slice(0,8),16))>>>24,t[1]=e>>>16&255,t[2]=e>>>8&255,t[3]=e&255,t[4]=(e=parseInt(r.slice(9,13),16))>>>8,t[5]=e&255,t[6]=(e=parseInt(r.slice(14,18),16))>>>8,t[7]=e&255,t[8]=(e=parseInt(r.slice(19,23),16))>>>8,t[9]=e&255,t[10]=(e=parseInt(r.slice(24,36),16))/1099511627776&255,t[11]=e/4294967296&255,t[12]=e>>>24&255,t[13]=e>>>16&255,t[14]=e>>>8&255,t[15]=e&255,t}var jn,Zr=te(()=>{"use strict";Xt();jn=of});function af(r){r=unescape(encodeURIComponent(r));for(var e=[],t=0;t<r.length;++t)e.push(r.charCodeAt(t));return e}function Yn(r,e,t){function n(s,o,i,a){if(typeof s=="string"&&(s=af(s)),typeof o=="string"&&(o=jn(o)),o.length!==16)throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");var c=new Uint8Array(16+s.length);if(c.set(o),c.set(s,o.length),c=t(c),c[6]=c[6]&15|e,c[8]=c[8]&63|128,i){a=a||0;for(var l=0;l<16;++l)i[a+l]=c[l];return i}return dt(c)}try{n.name=r}catch{}return n.DNS=cf,n.URL=uf,n}var cf,uf,Qr=te(()=>{"use strict";Jt();Zr();cf="6ba7b810-9dad-11d1-80b4-00c04fd430c8",uf="6ba7b811-9dad-11d1-80b4-00c04fd430c8"});function df(r){if(typeof r=="string"){var e=unescape(encodeURIComponent(r));r=new Uint8Array(e.length);for(var t=0;t<e.length;++t)r[t]=e.charCodeAt(t)}return lf(ff(hf(r),r.length*8))}function lf(r){for(var e=[],t=r.length*32,n="0123456789abcdef",s=0;s<t;s+=8){var o=r[s>>5]>>>s%32&255,i=parseInt(n.charAt(o>>>4&15)+n.charAt(o&15),16);e.push(i)}return e}function zo(r){return(r+64>>>9<<4)+14+1}function ff(r,e){r[e>>5]|=128<<e%32,r[zo(e)-1]=e;for(var t=1732584193,n=-271733879,s=-1732584194,o=271733878,i=0;i<r.length;i+=16){var a=t,c=n,l=s,d=o;t=me(t,n,s,o,r[i],7,-680876936),o=me(o,t,n,s,r[i+1],12,-389564586),s=me(s,o,t,n,r[i+2],17,606105819),n=me(n,s,o,t,r[i+3],22,-1044525330),t=me(t,n,s,o,r[i+4],7,-176418897),o=me(o,t,n,s,r[i+5],12,1200080426),s=me(s,o,t,n,r[i+6],17,-1473231341),n=me(n,s,o,t,r[i+7],22,-45705983),t=me(t,n,s,o,r[i+8],7,1770035416),o=me(o,t,n,s,r[i+9],12,-1958414417),s=me(s,o,t,n,r[i+10],17,-42063),n=me(n,s,o,t,r[i+11],22,-1990404162),t=me(t,n,s,o,r[i+12],7,1804603682),o=me(o,t,n,s,r[i+13],12,-40341101),s=me(s,o,t,n,r[i+14],17,-1502002290),n=me(n,s,o,t,r[i+15],22,1236535329),t=Se(t,n,s,o,r[i+1],5,-165796510),o=Se(o,t,n,s,r[i+6],9,-1069501632),s=Se(s,o,t,n,r[i+11],14,643717713),n=Se(n,s,o,t,r[i],20,-373897302),t=Se(t,n,s,o,r[i+5],5,-701558691),o=Se(o,t,n,s,r[i+10],9,38016083),s=Se(s,o,t,n,r[i+15],14,-660478335),n=Se(n,s,o,t,r[i+4],20,-405537848),t=Se(t,n,s,o,r[i+9],5,568446438),o=Se(o,t,n,s,r[i+14],9,-1019803690),s=Se(s,o,t,n,r[i+3],14,-187363961),n=Se(n,s,o,t,r[i+8],20,1163531501),t=Se(t,n,s,o,r[i+13],5,-1444681467),o=Se(o,t,n,s,r[i+2],9,-51403784),s=Se(s,o,t,n,r[i+7],14,1735328473),n=Se(n,s,o,t,r[i+12],20,-1926607734),t=Ee(t,n,s,o,r[i+5],4,-378558),o=Ee(o,t,n,s,r[i+8],11,-2022574463),s=Ee(s,o,t,n,r[i+11],16,1839030562),n=Ee(n,s,o,t,r[i+14],23,-35309556),t=Ee(t,n,s,o,r[i+1],4,-1530992060),o=Ee(o,t,n,s,r[i+4],11,1272893353),s=Ee(s,o,t,n,r[i+7],16,-155497632),n=Ee(n,s,o,t,r[i+10],23,-1094730640),t=Ee(t,n,s,o,r[i+13],4,681279174),o=Ee(o,t,n,s,r[i],11,-358537222),s=Ee(s,o,t,n,r[i+3],16,-722521979),n=Ee(n,s,o,t,r[i+6],23,76029189),t=Ee(t,n,s,o,r[i+9],4,-640364487),o=Ee(o,t,n,s,r[i+12],11,-421815835),s=Ee(s,o,t,n,r[i+15],16,530742520),n=Ee(n,s,o,t,r[i+2],23,-995338651),t=be(t,n,s,o,r[i],6,-198630844),o=be(o,t,n,s,r[i+7],10,1126891415),s=be(s,o,t,n,r[i+14],15,-1416354905),n=be(n,s,o,t,r[i+5],21,-57434055),t=be(t,n,s,o,r[i+12],6,1700485571),o=be(o,t,n,s,r[i+3],10,-1894986606),s=be(s,o,t,n,r[i+10],15,-1051523),n=be(n,s,o,t,r[i+1],21,-2054922799),t=be(t,n,s,o,r[i+8],6,1873313359),o=be(o,t,n,s,r[i+15],10,-30611744),s=be(s,o,t,n,r[i+6],15,-1560198380),n=be(n,s,o,t,r[i+13],21,1309151649),t=be(t,n,s,o,r[i+4],6,-145523070),o=be(o,t,n,s,r[i+11],10,-1120210379),s=be(s,o,t,n,r[i+2],15,718787259),n=be(n,s,o,t,r[i+9],21,-343485551),t=lt(t,a),n=lt(n,c),s=lt(s,l),o=lt(o,d)}return[t,n,s,o]}function hf(r){if(r.length===0)return[];for(var e=r.length*8,t=new Uint32Array(zo(e)),n=0;n<e;n+=8)t[n>>5]|=(r[n/8]&255)<<n%32;return t}function lt(r,e){var t=(r&65535)+(e&65535),n=(r>>16)+(e>>16)+(t>>16);return n<<16|t&65535}function _f(r,e){return r<<e|r>>>32-e}function Xn(r,e,t,n,s,o){return lt(_f(lt(lt(e,r),lt(n,o)),s),t)}function me(r,e,t,n,s,o,i){return Xn(e&t|~e&n,r,e,s,o,i)}function Se(r,e,t,n,s,o,i){return Xn(e&n|t&~n,r,e,s,o,i)}function Ee(r,e,t,n,s,o,i){return Xn(e^t^n,r,e,s,o,i)}function be(r,e,t,n,s,o,i){return Xn(t^(e|~n),r,e,s,o,i)}var Mo,Fo=te(()=>{"use strict";Mo=df});var pf,Ko,Wo=te(()=>{"use strict";Qr();Fo();pf=Yn("v3",48,Mo),Ko=pf});function yf(r,e,t){r=r||{};var n=r.random||(r.rng||Yt)();if(n[6]=n[6]&15|64,n[8]=n[8]&63|128,e){t=t||0;for(var s=0;s<16;++s)e[t+s]=n[s];return e}return dt(n)}var $o,Vo=te(()=>{"use strict";jr();Jt();$o=yf});function gf(r,e,t,n){switch(r){case 0:return e&t^~e&n;case 1:return e^t^n;case 2:return e&t^e&n^t&n;case 3:return e^t^n}}function es(r,e){return r<<e|r>>>32-e}function Rf(r){var e=[1518500249,1859775393,2400959708,3395469782],t=[1732584193,4023233417,2562383102,271733878,3285377520];if(typeof r=="string"){var n=unescape(encodeURIComponent(r));r=[];for(var s=0;s<n.length;++s)r.push(n.charCodeAt(s))}else Array.isArray(r)||(r=Array.prototype.slice.call(r));r.push(128);for(var o=r.length/4+2,i=Math.ceil(o/16),a=new Array(i),c=0;c<i;++c){for(var l=new Uint32Array(16),d=0;d<16;++d)l[d]=r[c*64+d*4]<<24|r[c*64+d*4+1]<<16|r[c*64+d*4+2]<<8|r[c*64+d*4+3];a[c]=l}a[i-1][14]=(r.length-1)*8/Math.pow(2,32),a[i-1][14]=Math.floor(a[i-1][14]),a[i-1][15]=(r.length-1)*8&4294967295;for(var _=0;_<i;++_){for(var I=new Uint32Array(80),p=0;p<16;++p)I[p]=a[_][p];for(var g=16;g<80;++g)I[g]=es(I[g-3]^I[g-8]^I[g-14]^I[g-16],1);for(var R=t[0],S=t[1],N=t[2],M=t[3],Z=t[4],v=0;v<80;++v){var pe=Math.floor(v/20),Le=es(R,5)+gf(pe,S,N,M)+Z+e[pe]+I[v]>>>0;Z=M,M=N,N=es(S,30)>>>0,S=R,R=Le}t[0]=t[0]+R>>>0,t[1]=t[1]+S>>>0,t[2]=t[2]+N>>>0,t[3]=t[3]+M>>>0,t[4]=t[4]+Z>>>0}return[t[0]>>24&255,t[0]>>16&255,t[0]>>8&255,t[0]&255,t[1]>>24&255,t[1]>>16&255,t[1]>>8&255,t[1]&255,t[2]>>24&255,t[2]>>16&255,t[2]>>8&255,t[2]&255,t[3]>>24&255,t[3]>>16&255,t[3]>>8&255,t[3]&255,t[4]>>24&255,t[4]>>16&255,t[4]>>8&255,t[4]&255]}var Go,qo=te(()=>{"use strict";Go=Rf});var mf,Ho,jo=te(()=>{"use strict";Qr();qo();mf=Yn("v5",80,Go),Ho=mf});var Yo,Xo=te(()=>{"use strict";Yo="00000000-0000-0000-0000-000000000000"});function Sf(r){if(!ut(r))throw TypeError("Invalid UUID");return parseInt(r.substr(14,1),16)}var Jo,Zo=te(()=>{"use strict";Xt();Jo=Sf});var ts={};gr(ts,{NIL:()=>Yo,parse:()=>jn,stringify:()=>dt,v1:()=>Do,v3:()=>Ko,v4:()=>$o,v5:()=>Ho,validate:()=>ut,version:()=>Jo});var ns=te(()=>{"use strict";Uo();Wo();Vo();jo();Xo();Zo();Xt();Jt();Zr()});var ei=pt((Qp,Qo)=>{"use strict";var Ef=(ns(),Rr(ts)).v4,bf=function(r,e,t,n){if(typeof r!="string")throw new TypeError(r+" must be a string");n=n||{};let s=typeof n.version=="number"?n.version:2;if(s!==1&&s!==2)throw new TypeError(s+" must be 1 or 2");let o={method:r};if(s===2&&(o.jsonrpc="2.0"),e){if(typeof e!="object"&&!Array.isArray(e))throw new TypeError(e+" must be an object, array or omitted");o.params=e}if(typeof t>"u"){let i=typeof n.generator=="function"?n.generator:function(){return Ef()};o.id=i(o,n)}else s===2&&t===null?n.notificationIdNull&&(o.id=null):o.id=t;return o};Qo.exports=bf});var ni=pt((ey,ti)=>{"use strict";var Af=(ns(),Rr(ts)).v4,If=ei(),Zt=function(r,e){if(!(this instanceof Zt))return new Zt(r,e);e||(e={}),this.options={reviver:typeof e.reviver<"u"?e.reviver:null,replacer:typeof e.replacer<"u"?e.replacer:null,generator:typeof e.generator<"u"?e.generator:function(){return Af()},version:typeof e.version<"u"?e.version:2,notificationIdNull:typeof e.notificationIdNull=="boolean"?e.notificationIdNull:!1},this.callServer=r};ti.exports=Zt;Zt.prototype.request=function(r,e,t,n){let s=this,o=null,i=Array.isArray(r)&&typeof e=="function";if(this.options.version===1&&i)throw new TypeError("JSON-RPC 1.0 does not support batching");if(i||!i&&r&&typeof r=="object"&&typeof e=="function")n=e,o=r;else{typeof t=="function"&&(n=t,t=void 0);let l=typeof n=="function";try{o=If(r,e,t,{generator:this.options.generator,version:this.options.version,notificationIdNull:this.options.notificationIdNull})}catch(d){if(l)return n(d);throw d}if(!l)return o}let c;try{c=JSON.stringify(o,this.options.replacer)}catch(l){return n(l)}return this.callServer(c,function(l,d){s._parseResponse(l,d,n)}),o};Zt.prototype._parseResponse=function(r,e,t){if(r){t(r);return}if(!e)return t();let n;try{n=JSON.parse(e,this.options.reviver)}catch(s){return t(s)}if(t.length===3)if(Array.isArray(n)){let s=function(i){return typeof i.error<"u"},o=function(i){return!s(i)};return t(null,n.filter(s),n.filter(o))}else return t(null,n.error,n.result);t(null,n)}});var si=pt((ty,rs)=>{"use strict";var wf=Object.prototype.hasOwnProperty,Oe="~";function Qt(){}Object.create&&(Qt.prototype=Object.create(null),new Qt().__proto__||(Oe=!1));function Of(r,e,t){this.fn=r,this.context=e,this.once=t||!1}function ri(r,e,t,n,s){if(typeof t!="function")throw new TypeError("The listener must be a function");var o=new Of(t,n||r,s),i=Oe?Oe+e:e;return r._events[i]?r._events[i].fn?r._events[i]=[r._events[i],o]:r._events[i].push(o):(r._events[i]=o,r._eventsCount++),r}function Jn(r,e){--r._eventsCount===0?r._events=new Qt:delete r._events[e]}function Ae(){this._events=new Qt,this._eventsCount=0}Ae.prototype.eventNames=function(){var e=[],t,n;if(this._eventsCount===0)return e;for(n in t=this._events)wf.call(t,n)&&e.push(Oe?n.slice(1):n);return Object.getOwnPropertySymbols?e.concat(Object.getOwnPropertySymbols(t)):e};Ae.prototype.listeners=function(e){var t=Oe?Oe+e:e,n=this._events[t];if(!n)return[];if(n.fn)return[n.fn];for(var s=0,o=n.length,i=new Array(o);s<o;s++)i[s]=n[s].fn;return i};Ae.prototype.listenerCount=function(e){var t=Oe?Oe+e:e,n=this._events[t];return n?n.fn?1:n.length:0};Ae.prototype.emit=function(e,t,n,s,o,i){var a=Oe?Oe+e:e;if(!this._events[a])return!1;var c=this._events[a],l=arguments.length,d,_;if(c.fn){switch(c.once&&this.removeListener(e,c.fn,void 0,!0),l){case 1:return c.fn.call(c.context),!0;case 2:return c.fn.call(c.context,t),!0;case 3:return c.fn.call(c.context,t,n),!0;case 4:return c.fn.call(c.context,t,n,s),!0;case 5:return c.fn.call(c.context,t,n,s,o),!0;case 6:return c.fn.call(c.context,t,n,s,o,i),!0}for(_=1,d=new Array(l-1);_<l;_++)d[_-1]=arguments[_];c.fn.apply(c.context,d)}else{var I=c.length,p;for(_=0;_<I;_++)switch(c[_].once&&this.removeListener(e,c[_].fn,void 0,!0),l){case 1:c[_].fn.call(c[_].context);break;case 2:c[_].fn.call(c[_].context,t);break;case 3:c[_].fn.call(c[_].context,t,n);break;case 4:c[_].fn.call(c[_].context,t,n,s);break;default:if(!d)for(p=1,d=new Array(l-1);p<l;p++)d[p-1]=arguments[p];c[_].fn.apply(c[_].context,d)}}return!0};Ae.prototype.on=function(e,t,n){return ri(this,e,t,n,!1)};Ae.prototype.once=function(e,t,n){return ri(this,e,t,n,!0)};Ae.prototype.removeListener=function(e,t,n,s){var o=Oe?Oe+e:e;if(!this._events[o])return this;if(!t)return Jn(this,o),this;var i=this._events[o];if(i.fn)i.fn===t&&(!s||i.once)&&(!n||i.context===n)&&Jn(this,o);else{for(var a=0,c=[],l=i.length;a<l;a++)(i[a].fn!==t||s&&!i[a].once||n&&i[a].context!==n)&&c.push(i[a]);c.length?this._events[o]=c.length===1?c[0]:c:Jn(this,o)}return this};Ae.prototype.removeAllListeners=function(e){var t;return e?(t=Oe?Oe+e:e,this._events[t]&&Jn(this,t)):(this._events=new Qt,this._eventsCount=0),this};Ae.prototype.off=Ae.prototype.removeListener;Ae.prototype.addListener=Ae.prototype.on;Ae.prefixed=Oe;Ae.EventEmitter=Ae;typeof rs<"u"&&(rs.exports=Ae)});var Zn,oi=te(()=>{"use strict";Zn=et(si(),1)});function ai(r,e){return new kf(r,e)}var ii,kf,Nf,ci,ui=te(()=>{"use strict";ii=et(wr(),1);oi();kf=class extends Zn.default{socket;constructor(r,e,t){super(),this.socket=new window.WebSocket(r,t),this.socket.onopen=()=>this.emit("open"),this.socket.onmessage=n=>this.emit("message",n.data),this.socket.onerror=n=>this.emit("error",n),this.socket.onclose=n=>{this.emit("close",n.code,n.reason)}}send(r,e,t){let n=t||e;try{this.socket.send(r),n()}catch(s){n(s)}}close(r,e){this.socket.close(r,e)}addEventListener(r,e,t){this.socket.addEventListener(r,e,t)}};Nf=class{encode(r){return JSON.stringify(r)}decode(r){return JSON.parse(r)}},ci=class extends Zn.default{address;rpc_id;queue;options;autoconnect;ready;reconnect;reconnect_timer_id;reconnect_interval;max_reconnects;rest_options;current_reconnects;generate_request_id;socket;webSocketFactory;dataPack;constructor(r,e="ws://localhost:8080",l={},a,c){var d=l,{autoconnect:t=!0,reconnect:n=!0,reconnect_interval:s=1e3,max_reconnects:o=5}=d,i=De(d,["autoconnect","reconnect","reconnect_interval","max_reconnects"]);super(),this.webSocketFactory=r,this.queue={},this.rpc_id=0,this.address=e,this.autoconnect=t,this.ready=!1,this.reconnect=n,this.reconnect_timer_id=void 0,this.reconnect_interval=s,this.max_reconnects=o,this.rest_options=i,this.current_reconnects=0,this.generate_request_id=a||(()=>typeof this.rpc_id=="number"?++this.rpc_id:Number(this.rpc_id)+1),c?this.dataPack=c:this.dataPack=new Nf,this.autoconnect&&this._connect(this.address,C({autoconnect:this.autoconnect,reconnect:this.reconnect,reconnect_interval:this.reconnect_interval,max_reconnects:this.max_reconnects},this.rest_options))}connect(){this.socket||this._connect(this.address,C({autoconnect:this.autoconnect,reconnect:this.reconnect,reconnect_interval:this.reconnect_interval,max_reconnects:this.max_reconnects},this.rest_options))}call(r,e,t,n){return!n&&typeof t=="object"&&(n=t,t=null),new Promise((s,o)=>{if(!this.ready)return o(new Error("socket not ready"));let i=this.generate_request_id(r,e),a={jsonrpc:"2.0",method:r,params:e||void 0,id:i};this.socket.send(this.dataPack.encode(a),n,c=>{if(c)return o(c);this.queue[i]={promise:[s,o]},t&&(this.queue[i].timeout=setTimeout(()=>{delete this.queue[i],o(new Error("reply timeout"))},t))})})}login(r){return y(this,null,function*(){let e=yield this.call("rpc.login",r);if(!e)throw new Error("authentication failed");return e})}listMethods(){return y(this,null,function*(){return yield this.call("__listMethods")})}notify(r,e){return new Promise((t,n)=>{if(!this.ready)return n(new Error("socket not ready"));let s={jsonrpc:"2.0",method:r,params:e};this.socket.send(this.dataPack.encode(s),o=>{if(o)return n(o);t()})})}subscribe(r){return y(this,null,function*(){typeof r=="string"&&(r=[r]);let e=yield this.call("rpc.on",r);if(typeof r=="string"&&e[r]!=="ok")throw new Error("Failed subscribing to an event '"+r+"' with: "+e[r]);return e})}unsubscribe(r){return y(this,null,function*(){typeof r=="string"&&(r=[r]);let e=yield this.call("rpc.off",r);if(typeof r=="string"&&e[r]!=="ok")throw new Error("Failed unsubscribing from an event with: "+e);return e})}close(r,e){this.socket.close(r||1e3,e)}setAutoReconnect(r){this.reconnect=r}setReconnectInterval(r){this.reconnect_interval=r}setMaxReconnects(r){this.max_reconnects=r}_connect(r,e){clearTimeout(this.reconnect_timer_id),this.socket=this.webSocketFactory(r,e),this.socket.addEventListener("open",()=>{this.ready=!0,this.emit("open"),this.current_reconnects=0}),this.socket.addEventListener("message",({data:t})=>{t instanceof ArrayBuffer&&(t=ii.Buffer.from(t).toString());try{t=this.dataPack.decode(t)}catch{return}if(t.notification&&this.listeners(t.notification).length){if(!Object.keys(t.params).length)return this.emit(t.notification);let n=[t.notification];if(t.params.constructor===Object)n.push(t.params);else for(let s=0;s<t.params.length;s++)n.push(t.params[s]);return Promise.resolve().then(()=>{this.emit.apply(this,n)})}if(!this.queue[t.id])return t.method?Promise.resolve().then(()=>{this.emit(t.method,t?.params)}):void 0;"error"in t=="result"in t&&this.queue[t.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.')),this.queue[t.id].timeout&&clearTimeout(this.queue[t.id].timeout),t.error?this.queue[t.id].promise[1](t.error):this.queue[t.id].promise[0](t.result),delete this.queue[t.id]}),this.socket.addEventListener("error",t=>this.emit("error",t)),this.socket.addEventListener("close",({code:t,reason:n})=>{this.ready&&setTimeout(()=>this.emit("close",t,n),0),this.ready=!1,this.socket=void 0,t!==1e3&&(this.current_reconnects++,this.reconnect&&(this.max_reconnects>this.current_reconnects||this.max_reconnects===0)&&(this.reconnect_timer_id=setTimeout(()=>this._connect(r,e),this.reconnect_interval)))})}}});var x_={};gr(x_,{Account:()=>fs,AddressLookupTableAccount:()=>an,AddressLookupTableInstruction:()=>ws,AddressLookupTableProgram:()=>un,Authorized:()=>dr,BLOCKHASH_CACHE_TIMEOUT_MS:()=>zi,BPF_LOADER_DEPRECATED_PROGRAM_ID:()=>Cf,BPF_LOADER_PROGRAM_ID:()=>Yf,BpfLoader:()=>ms,COMPUTE_BUDGET_INSTRUCTION_LAYOUTS:()=>Ye,ComputeBudgetInstruction:()=>Os,ComputeBudgetProgram:()=>dn,Connection:()=>Is,Ed25519Program:()=>cr,Enum:()=>ls,EpochSchedule:()=>or,FeeCalculatorLayout:()=>Pi,Keypair:()=>ar,LAMPORTS_PER_SOL:()=>B_,LOOKUP_TABLE_INSTRUCTION_LAYOUTS:()=>st,Loader:()=>Rs,Lockup:()=>wt,MAX_SEED_LENGTH:()=>vi,Message:()=>Ze,MessageAccountKeys:()=>At,MessageV0:()=>Pt,NONCE_ACCOUNT_LENGTH:()=>ys,NonceAccount:()=>sr,PACKET_DATA_SIZE:()=>ht,PUBLIC_KEY_LENGTH:()=>Je,PublicKey:()=>w,SIGNATURE_LENGTH_IN_BYTES:()=>rn,SOLANA_SCHEMA:()=>tn,STAKE_CONFIG_ID:()=>Yi,STAKE_INSTRUCTION_LAYOUTS:()=>de,SYSTEM_INSTRUCTION_LAYOUTS:()=>ee,SYSVAR_CLOCK_PUBKEY:()=>He,SYSVAR_EPOCH_SCHEDULE_PUBKEY:()=>Wf,SYSVAR_INSTRUCTIONS_PUBKEY:()=>$f,SYSVAR_RECENT_BLOCKHASHES_PUBKEY:()=>er,SYSVAR_RENT_PUBKEY:()=>Dt,SYSVAR_REWARDS_PUBKEY:()=>Vf,SYSVAR_SLOT_HASHES_PUBKEY:()=>Gf,SYSVAR_SLOT_HISTORY_PUBKEY:()=>qf,SYSVAR_STAKE_HISTORY_PUBKEY:()=>tr,Secp256k1Program:()=>ur,SendTransactionError:()=>It,SolanaJSONRPCError:()=>T,SolanaJSONRPCErrorCode:()=>Hf,StakeAuthorizationLayout:()=>I_,StakeInstruction:()=>ks,StakeProgram:()=>zt,Struct:()=>nn,SystemInstruction:()=>gs,SystemProgram:()=>_e,Transaction:()=>Y,TransactionExpiredBlockheightExceededError:()=>sn,TransactionExpiredNonceInvalidError:()=>ft,TransactionExpiredTimeoutError:()=>on,TransactionInstruction:()=>X,TransactionMessage:()=>hs,TransactionStatus:()=>rt,VALIDATOR_INFO_KEY:()=>Xi,VERSION_PREFIX_MASK:()=>fr,VOTE_PROGRAM_ID:()=>k_,ValidatorInfo:()=>Ts,VersionedMessage:()=>Cs,VersionedTransaction:()=>_s,VoteAccount:()=>Ls,VoteAuthorizationLayout:()=>w_,VoteInit:()=>lr,VoteInstruction:()=>Ns,VoteProgram:()=>Mt,clusterApiUrl:()=>v_,sendAndConfirmRawTransaction:()=>C_,sendAndConfirmTransaction:()=>ps});function li(r){try{return yt.ExtendedPoint.fromHex(r),!0}catch{return!1}}function vf(r){return r._bn!==void 0}function Ci(r,e){let t=s=>{if(s.span>=0)return s.span;if(typeof s.alloc=="function")return s.alloc(e[s.property]);if("count"in s&&"elementLayout"in s){let o=e[s.property];if(Array.isArray(o))return o.length*t(s.elementLayout)}else if("fields"in s)return Ci({layout:s},e[s.property]);return 0},n=0;return r.layout.fields.forEach(s=>{n+=t(s)}),n}function Ne(r){let e=0,t=0;for(;;){let n=r.shift();if(e|=(n&127)<<t*7,t+=1,!(n&128))break}return e}function Be(r,e){let t=e;for(;;){let n=t&127;if(t>>=7,t==0){r.push(n);break}else n|=128,r.push(n)}}function q(r,e){if(!r)throw new Error(e||"Assertion failed")}function je(r){if(r.length===0)throw new Error(Bi);return r.shift()}function Te(r,...e){let[t]=e;if(e.length===2?t+(e[1]??0)>r.length:t>=r.length)throw new Error(Bi);return r.splice(...e)}function ps(r,e,t,n){return y(this,null,function*(){let s=n&&{skipPreflight:n.skipPreflight,preflightCommitment:n.preflightCommitment||n.commitment,maxRetries:n.maxRetries,minContextSlot:n.minContextSlot},o=yield r.sendTransaction(e,t,s),i;if(e.recentBlockhash!=null&&e.lastValidBlockHeight!=null)i=(yield r.confirmTransaction({abortSignal:n?.abortSignal,signature:o,blockhash:e.recentBlockhash,lastValidBlockHeight:e.lastValidBlockHeight},n&&n.commitment)).value;else if(e.minNonceContextSlot!=null&&e.nonceInfo!=null){let{nonceInstruction:a}=e.nonceInfo,c=a.keys[0].pubkey;i=(yield r.confirmTransaction({abortSignal:n?.abortSignal,minContextSlot:e.minNonceContextSlot,nonceAccountPubkey:c,nonceValue:e.nonceInfo.nonce,signature:o},n&&n.commitment)).value}else n?.abortSignal!=null&&console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable."),i=(yield r.confirmTransaction(o,n&&n.commitment)).value;if(i.err)throw o!=null?new It({action:"send",signature:o,transactionMessage:`Status: (${JSON.stringify(i)})`}):new Error(`Transaction ${o} failed (${JSON.stringify(i)})`);return o})}function Et(r){return new Promise(e=>setTimeout(e,r))}function $(r,e){let t=r.layout.span>=0?r.layout.span:Ci(r,e),n=P.Buffer.alloc(t),s=Object.assign({instruction:r.index},e);return r.layout.encode(s,n),n}function j(r,e){let t;try{t=r.layout.decode(e)}catch(n){throw new Error("invalid instruction; "+n)}if(t.instruction!==r.index)throw new Error(`invalid instruction; instruction index mismatch ${t.instruction} != ${r.index}`);return t}function Ut(r){let e=(0,Ni.blob)(8,r),t=e.decode.bind(e),n=e.encode.bind(e),s=e,o=ko();return s.decode=(i,a)=>{let c=t(i,a);return o.decode(c)},s.encode=(i,a,c)=>{let l=o.encode(i);return n(l,a,c)},s}function Xf(r){return r&&r.__esModule&&Object.prototype.hasOwnProperty.call(r,"default")?r.default:r}function Jf(){if(hi)return ss;hi=1;var r=Object.prototype.toString,e=Object.keys||function(n){var s=[];for(var o in n)s.push(o);return s};function t(n,s){var o,i,a,c,l,d,_;if(n===!0)return"true";if(n===!1)return"false";switch(typeof n){case"object":if(n===null)return null;if(n.toJSON&&typeof n.toJSON=="function")return t(n.toJSON(),s);if(_=r.call(n),_==="[object Array]"){for(a="[",i=n.length-1,o=0;o<i;o++)a+=t(n[o],!0)+",";return i>-1&&(a+=t(n[o],!0)),a+"]"}else if(_==="[object Object]"){for(c=e(n).sort(),i=c.length,a="",o=0;o<i;)l=c[o],d=t(n[l],!1),d!==void 0&&(a&&(a+=","),a+=JSON.stringify(l)+":"+d),o++;return"{"+a+"}"}else return JSON.stringify(n);case"function":case"undefined":return s?null:void 0;case"string":return JSON.stringify(n);default:return isFinite(n)?n:null}}return ss=function(n){var s=t(n,!1);if(s!==void 0)return""+s},ss}function os(r){let e=0;for(;r>1;)r/=2,e++;return e}function Qf(r){return r===0?1:(r--,r|=r>>1,r|=r>>2,r|=r>>4,r|=r>>8,r|=r>>16,r|=r>>32,r+1)}function th(r,e){let t;try{t=r.layout.decode(e)}catch(n){throw new Error("invalid instruction; "+n)}if(t.typeIndex!==r.index)throw new Error(`invalid account data; account type mismatch ${t.typeIndex} != ${r.index}`);return t}function sh(r){let e=r.match(rh);if(e==null)throw TypeError(`Failed to validate endpoint URL \`${r}\``);let[t,n,s,o]=e,i=r.startsWith("https:")?"wss:":"ws:",a=s==null?null:parseInt(s.slice(1),10),c=a==null?"":`:${a+1}`;return`${i}//${n}${c}${o}`}function oh(r){if(/^https?:/.test(r)===!1)throw new TypeError("Endpoint URL must start with `http:` or `https:`.");return r}function Q(r){let e,t;if(typeof r=="string")e=r;else if(r){let n=r,{commitment:s}=n,o=De(n,["commitment"]);e=s,t=o}return{commitment:e,config:t}}function yi(r){return r.map(e=>"memcmp"in e?F(C({},e),{memcmp:F(C({},e.memcmp),{encoding:e.memcmp.encoding??"base58"})}):e)}function Mi(r){return Re([m({jsonrpc:re("2.0"),id:E(),result:r}),m({jsonrpc:re("2.0"),id:E(),error:m({code:St(),message:E(),data:B(vo())})})])}function U(r){return xt(Mi(r),ih,e=>"error"in e?e:F(C({},e),{result:A(e.result,r)}))}function ie(r){return U(m({context:m({slot:f()}),value:r}))}function hr(r){return m({context:m({slot:f()}),value:r})}function is(r,e){return r===0?new Pt({header:e.header,staticAccountKeys:e.accountKeys.map(t=>new w(t)),recentBlockhash:e.recentBlockhash,compiledInstructions:e.instructions.map(t=>({programIdIndex:t.programIdIndex,accountKeyIndexes:t.accounts,data:le.default.decode(t.data)})),addressTableLookups:e.addressTableLookups}):new Ze(e)}function Sh(r,e,t,n,s,o){let i=t||eh,a;o!=null&&console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");let c;return n&&(c=(d,_)=>y(this,null,function*(){let I=yield new Promise((p,g)=>{try{n(d,_,(R,S)=>p([R,S]))}catch(R){g(R)}});return yield i(...I)})),new Ti.default((d,_)=>y(this,null,function*(){let I={method:"POST",body:d,agent:a,headers:Object.assign({"Content-Type":"application/json"},e||{},S_)};try{let p=5,g,R=500;for(;c?g=yield c(r,I):g=yield i(r,I),!(g.status!==429||s===!0||(p-=1,p===0));)console.error(`Server responded with ${g.status} ${g.statusText}.  Retrying after ${R}ms delay...`),yield Et(R),R*=2;let S=yield g.text();g.ok?_(null,S):_(new Error(`${g.status} ${g.statusText}: ${S}`))}catch(p){p instanceof Error&&_(p)}}),{})}function Eh(r){return(e,t)=>new Promise((n,s)=>{r.request(e,t,(o,i)=>{if(o){s(o);return}n(i)})})}function bh(r){return e=>new Promise((t,n)=>{e.length===0&&t([]);let s=e.map(o=>r.request(o.methodName,o.args));r.request(s,(o,i)=>{if(o){n(o);return}t(i)})})}function T_({authorizedVoter:r,epoch:e}){return{epoch:e,authorizedVoter:new w(r)}}function Oi({authorizedPubkey:r,epochOfLastAuthorizedSwitch:e,targetEpoch:t}){return{authorizedPubkey:new w(r),epochOfLastAuthorizedSwitch:e,targetEpoch:t}}function L_({buf:r,idx:e,isEmpty:t}){return t?[]:[...r.slice(e+1).map(Oi),...r.slice(0,e).map(Oi)]}function v_(r,e){let t=e===!1?"http":"https";if(!r)return ki[t].devnet;let n=ki[t][r];if(!n)throw new Error(`Unknown ${t} cluster: ${r}`);return n}function C_(r,e,t,n){return y(this,null,function*(){let s,o;t&&Object.prototype.hasOwnProperty.call(t,"lastValidBlockHeight")||t&&Object.prototype.hasOwnProperty.call(t,"nonceValue")?(s=t,o=n):o=t;let i=o&&{skipPreflight:o.skipPreflight,preflightCommitment:o.preflightCommitment||o.commitment,minContextSlot:o.minContextSlot},a=yield r.sendRawTransaction(e,i),c=o&&o.commitment,d=(yield s?r.confirmTransaction(s,c):r.confirmTransaction(a,c)).value;if(d.err)throw a!=null?new It({action:i?.skipPreflight?"send":"simulate",signature:a,transactionMessage:`Status: (${JSON.stringify(d)})`}):new Error(`Raw transaction ${a} failed (${JSON.stringify(d)})`);return a})}var P,ds,le,Ft,u,Ni,Ti,Tf,di,nr,vs,Lf,z,nn,ls,tn,Li,vi,Je,fi,w,fs,Cf,ht,fr,rn,sn,on,ft,At,K,Bf,bt,xf,Pf,Df,Uf,rr,Bi,Ze,Pt,Cs,rt,zf,X,Y,hs,_s,Mf,Ff,Kf,xi,He,Wf,$f,er,Dt,Vf,Gf,qf,tr,It,Hf,T,Pi,Di,ys,sr,gs,ee,_e,jf,Rs,Yf,ms,ss,hi,Zf,_i,en,or,eh,Ss,pi,an,nh,rh,oe,Ui,Bs,zi,ih,ah,ch,uh,dh,lh,fh,hh,Ot,_h,ph,yh,gh,Rh,gi,mh,Ah,Ih,wh,Oh,kh,Nh,Th,Lh,Es,vh,Ch,bs,Bh,xh,cn,Ph,Dh,As,Uh,zh,Mh,Fh,Kh,Wh,$h,Vh,Gh,qh,Hh,jh,Yh,Xh,Ri,Jh,Zh,Qh,e_,t_,Fi,xs,Ki,Wi,$i,Vi,n_,r_,Gi,qi,ir,Hi,_r,Ps,Kt,kt,s_,o_,i_,a_,c_,u_,d_,mi,as,Qn,l_,f_,h_,__,p_,y_,g_,R_,m_,S_,Is,ar,st,ws,un,Os,Ye,dn,Si,Ei,bi,Ai,cr,E_,b_,Ii,cs,wi,A_,us,ur,ji,Yi,dr,wt,ks,de,I_,zt,lr,Ns,Xe,w_,Mt,Xi,O_,Ts,k_,N_,Ls,ki,B_,P_=te(()=>{P=et(wr());to();ds=et(js()),le=et(kr());la();Ft=et(fo()),u=et(Pr()),Ni=et(Pr());No();Co();Ti=et(ni());ui();ia();da();Tf=yt.utils.randomPrivateKey,di=()=>{let r=yt.utils.randomPrivateKey(),e=nr(r),t=new Uint8Array(64);return t.set(r),t.set(e,32),{publicKey:e,secretKey:t}},nr=yt.getPublicKey;vs=(r,e)=>yt.sign(r,e.slice(0,32)),Lf=yt.verify,z=r=>P.Buffer.isBuffer(r)?r:r instanceof Uint8Array?P.Buffer.from(r.buffer,r.byteOffset,r.byteLength):P.Buffer.from(r),nn=class{constructor(e){Object.assign(this,e)}encode(){return P.Buffer.from((0,Ft.serialize)(tn,this))}static decode(e){return(0,Ft.deserialize)(tn,this,e)}static decodeUnchecked(e){return(0,Ft.deserializeUnchecked)(tn,this,e)}},ls=class extends nn{constructor(e){if(super(e),this.enum="",Object.keys(e).length!==1)throw new Error("Enum can only take single value");Object.keys(e).map(t=>{this.enum=t})}},tn=new Map,vi=32,Je=32;fi=1,w=class r extends nn{constructor(e){if(super({}),this._bn=void 0,vf(e))this._bn=e._bn;else{if(typeof e=="string"){let t=le.default.decode(e);if(t.length!=Je)throw new Error("Invalid public key input");this._bn=new ds.default(t)}else this._bn=new ds.default(e);if(this._bn.byteLength()>Je)throw new Error("Invalid public key input")}}static unique(){let e=new r(fi);return fi+=1,new r(e.toBuffer())}equals(e){return this._bn.eq(e._bn)}toBase58(){return le.default.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){let e=this.toBuffer();return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}toBuffer(){let e=this._bn.toArrayLike(P.Buffer);if(e.length===Je)return e;let t=P.Buffer.alloc(32);return e.copy(t,32-e.length),t}get[Symbol.toStringTag](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static createWithSeed(e,t,n){return y(this,null,function*(){let s=P.Buffer.concat([e.toBuffer(),P.Buffer.from(t),n.toBuffer()]),o=Ir(s);return new r(o)})}static createProgramAddressSync(e,t){let n=P.Buffer.alloc(0);e.forEach(function(o){if(o.length>vi)throw new TypeError("Max seed length exceeded");n=P.Buffer.concat([n,z(o)])}),n=P.Buffer.concat([n,t.toBuffer(),P.Buffer.from("ProgramDerivedAddress")]);let s=Ir(n);if(li(s))throw new Error("Invalid seeds, address must fall off the curve");return new r(s)}static createProgramAddress(e,t){return y(this,null,function*(){return this.createProgramAddressSync(e,t)})}static findProgramAddressSync(e,t){let n=255,s;for(;n!=0;){try{let o=e.concat(P.Buffer.from([n]));s=this.createProgramAddressSync(o,t)}catch(o){if(o instanceof TypeError)throw o;n--;continue}return[s,n]}throw new Error("Unable to find a viable program address nonce")}static findProgramAddress(e,t){return y(this,null,function*(){return this.findProgramAddressSync(e,t)})}static isOnCurve(e){let t=new r(e);return li(t.toBytes())}};Li=w;w.default=new Li("11111111111111111111111111111111");tn.set(w,{kind:"struct",fields:[["_bn","u256"]]});fs=class{constructor(e){if(this._publicKey=void 0,this._secretKey=void 0,e){let t=z(e);if(e.length!==64)throw new Error("bad secret key size");this._publicKey=t.slice(32,64),this._secretKey=t.slice(0,32)}else this._secretKey=z(Tf()),this._publicKey=z(nr(this._secretKey))}get publicKey(){return new w(this._publicKey)}get secretKey(){return P.Buffer.concat([this._secretKey,this._publicKey],64)}},Cf=new w("BPFLoader1111111111111111111111111111111111"),ht=1232,fr=127,rn=64,sn=class extends Error{constructor(e){super(`Signature ${e} has expired: block height exceeded.`),this.signature=void 0,this.signature=e}};Object.defineProperty(sn.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});on=class extends Error{constructor(e,t){super(`Transaction was not confirmed in ${t.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${e} using the Solana Explorer or CLI tools.`),this.signature=void 0,this.signature=e}};Object.defineProperty(on.prototype,"name",{value:"TransactionExpiredTimeoutError"});ft=class extends Error{constructor(e){super(`Signature ${e} has expired: the nonce is no longer valid.`),this.signature=void 0,this.signature=e}};Object.defineProperty(ft.prototype,"name",{value:"TransactionExpiredNonceInvalidError"});At=class{constructor(e,t){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=e,this.accountKeysFromLookups=t}keySegments(){let e=[this.staticAccountKeys];return this.accountKeysFromLookups&&(e.push(this.accountKeysFromLookups.writable),e.push(this.accountKeysFromLookups.readonly)),e}get(e){for(let t of this.keySegments()){if(e<t.length)return t[e];e-=t.length}}get length(){return this.keySegments().flat().length}compileInstructions(e){if(this.length>256)throw new Error("Account index overflow encountered during compilation");let n=new Map;this.keySegments().flat().forEach((o,i)=>{n.set(o.toBase58(),i)});let s=o=>{let i=n.get(o.toBase58());if(i===void 0)throw new Error("Encountered an unknown instruction account key during compilation");return i};return e.map(o=>({programIdIndex:s(o.programId),accountKeyIndexes:o.keys.map(i=>s(i.pubkey)),data:o.data}))}},K=(r="publicKey")=>u.blob(32,r),Bf=(r="signature")=>u.blob(64,r),bt=(r="string")=>{let e=u.struct([u.u32("length"),u.u32("lengthPadding"),u.blob(u.offset(u.u32(),-8),"chars")],r),t=e.decode.bind(e),n=e.encode.bind(e),s=e;return s.decode=(o,i)=>t(o,i).chars.toString(),s.encode=(o,i,a)=>{let c={chars:P.Buffer.from(o,"utf8")};return n(c,i,a)},s.alloc=o=>u.u32().span+u.u32().span+P.Buffer.from(o,"utf8").length,s},xf=(r="authorized")=>u.struct([K("staker"),K("withdrawer")],r),Pf=(r="lockup")=>u.struct([u.ns64("unixTimestamp"),u.ns64("epoch"),K("custodian")],r),Df=(r="voteInit")=>u.struct([K("nodePubkey"),K("authorizedVoter"),K("authorizedWithdrawer"),u.u8("commission")],r),Uf=(r="voteAuthorizeWithSeedArgs")=>u.struct([u.u32("voteAuthorizationType"),K("currentAuthorityDerivedKeyOwnerPubkey"),bt("currentAuthorityDerivedKeySeed"),K("newAuthorized")],r);rr=class r{constructor(e,t){this.payer=void 0,this.keyMetaMap=void 0,this.payer=e,this.keyMetaMap=t}static compile(e,t){let n=new Map,s=i=>{let a=i.toBase58(),c=n.get(a);return c===void 0&&(c={isSigner:!1,isWritable:!1,isInvoked:!1},n.set(a,c)),c},o=s(t);o.isSigner=!0,o.isWritable=!0;for(let i of e){s(i.programId).isInvoked=!0;for(let a of i.keys){let c=s(a.pubkey);c.isSigner||=a.isSigner,c.isWritable||=a.isWritable}}return new r(t,n)}getMessageComponents(){let e=[...this.keyMetaMap.entries()];q(e.length<=256,"Max static account keys length exceeded");let t=e.filter(([,c])=>c.isSigner&&c.isWritable),n=e.filter(([,c])=>c.isSigner&&!c.isWritable),s=e.filter(([,c])=>!c.isSigner&&c.isWritable),o=e.filter(([,c])=>!c.isSigner&&!c.isWritable),i={numRequiredSignatures:t.length+n.length,numReadonlySignedAccounts:n.length,numReadonlyUnsignedAccounts:o.length};{q(t.length>0,"Expected at least one writable signer key");let[c]=t[0];q(c===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}let a=[...t.map(([c])=>new w(c)),...n.map(([c])=>new w(c)),...s.map(([c])=>new w(c)),...o.map(([c])=>new w(c))];return[i,a]}extractTableLookup(e){let[t,n]=this.drainKeysFoundInLookupTable(e.state.addresses,i=>!i.isSigner&&!i.isInvoked&&i.isWritable),[s,o]=this.drainKeysFoundInLookupTable(e.state.addresses,i=>!i.isSigner&&!i.isInvoked&&!i.isWritable);if(!(t.length===0&&s.length===0))return[{accountKey:e.key,writableIndexes:t,readonlyIndexes:s},{writable:n,readonly:o}]}drainKeysFoundInLookupTable(e,t){let n=new Array,s=new Array;for(let[o,i]of this.keyMetaMap.entries())if(t(i)){let a=new w(o),c=e.findIndex(l=>l.equals(a));c>=0&&(q(c<256,"Max lookup table index exceeded"),n.push(c),s.push(a),this.keyMetaMap.delete(o))}return[n,s]}},Bi="Reached end of buffer unexpectedly";Ze=class r{constructor(e){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=e.header,this.accountKeys=e.accountKeys.map(t=>new w(t)),this.recentBlockhash=e.recentBlockhash,this.instructions=e.instructions,this.instructions.forEach(t=>this.indexToProgramIds.set(t.programIdIndex,this.accountKeys[t.programIdIndex]))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map(e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:le.default.decode(e.data)}))}get addressTableLookups(){return[]}getAccountKeys(){return new At(this.staticAccountKeys)}static compile(e){let t=rr.compile(e.instructions,e.payerKey),[n,s]=t.getMessageComponents(),i=new At(s).compileInstructions(e.instructions).map(a=>({programIdIndex:a.programIdIndex,accounts:a.accountKeyIndexes,data:le.default.encode(a.data)}));return new r({header:n,accountKeys:s,recentBlockhash:e.recentBlockhash,instructions:i})}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){let t=this.header.numRequiredSignatures;if(e>=this.header.numRequiredSignatures){let n=e-t,o=this.accountKeys.length-t-this.header.numReadonlyUnsignedAccounts;return n<o}else{let n=t-this.header.numReadonlySignedAccounts;return e<n}}isProgramId(e){return this.indexToProgramIds.has(e)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter((e,t)=>!this.isProgramId(t))}serialize(){let e=this.accountKeys.length,t=[];Be(t,e);let n=this.instructions.map(_=>{let{accounts:I,programIdIndex:p}=_,g=Array.from(le.default.decode(_.data)),R=[];Be(R,I.length);let S=[];return Be(S,g.length),{programIdIndex:p,keyIndicesCount:P.Buffer.from(R),keyIndices:I,dataLength:P.Buffer.from(S),data:g}}),s=[];Be(s,n.length);let o=P.Buffer.alloc(ht);P.Buffer.from(s).copy(o);let i=s.length;n.forEach(_=>{let p=u.struct([u.u8("programIdIndex"),u.blob(_.keyIndicesCount.length,"keyIndicesCount"),u.seq(u.u8("keyIndex"),_.keyIndices.length,"keyIndices"),u.blob(_.dataLength.length,"dataLength"),u.seq(u.u8("userdatum"),_.data.length,"data")]).encode(_,o,i);i+=p}),o=o.slice(0,i);let a=u.struct([u.blob(1,"numRequiredSignatures"),u.blob(1,"numReadonlySignedAccounts"),u.blob(1,"numReadonlyUnsignedAccounts"),u.blob(t.length,"keyCount"),u.seq(K("key"),e,"keys"),K("recentBlockhash")]),c={numRequiredSignatures:P.Buffer.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:P.Buffer.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:P.Buffer.from([this.header.numReadonlyUnsignedAccounts]),keyCount:P.Buffer.from(t),keys:this.accountKeys.map(_=>z(_.toBytes())),recentBlockhash:le.default.decode(this.recentBlockhash)},l=P.Buffer.alloc(2048),d=a.encode(c,l);return o.copy(l,d),l.slice(0,d+o.length)}static from(e){let t=[...e],n=je(t);if(n!==(n&fr))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");let s=je(t),o=je(t),i=Ne(t),a=[];for(let I=0;I<i;I++){let p=Te(t,0,Je);a.push(new w(P.Buffer.from(p)))}let c=Te(t,0,Je),l=Ne(t),d=[];for(let I=0;I<l;I++){let p=je(t),g=Ne(t),R=Te(t,0,g),S=Ne(t),N=Te(t,0,S),M=le.default.encode(P.Buffer.from(N));d.push({programIdIndex:p,accounts:R,data:M})}let _={header:{numRequiredSignatures:n,numReadonlySignedAccounts:s,numReadonlyUnsignedAccounts:o},recentBlockhash:le.default.encode(P.Buffer.from(c)),accountKeys:a,instructions:d};return new r(_)}},Pt=class r{constructor(e){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=e.header,this.staticAccountKeys=e.staticAccountKeys,this.recentBlockhash=e.recentBlockhash,this.compiledInstructions=e.compiledInstructions,this.addressTableLookups=e.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let e=0;for(let t of this.addressTableLookups)e+=t.readonlyIndexes.length+t.writableIndexes.length;return e}getAccountKeys(e){let t;if(e&&"accountKeysFromLookups"in e&&e.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=e.accountKeysFromLookups.writable.length+e.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");t=e.accountKeysFromLookups}else if(e&&"addressLookupTableAccounts"in e&&e.addressLookupTableAccounts)t=this.resolveAddressTableLookups(e.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new At(this.staticAccountKeys,t)}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){let t=this.header.numRequiredSignatures,n=this.staticAccountKeys.length;if(e>=n){let s=e-n,o=this.addressTableLookups.reduce((i,a)=>i+a.writableIndexes.length,0);return s<o}else if(e>=this.header.numRequiredSignatures){let s=e-t,i=n-t-this.header.numReadonlyUnsignedAccounts;return s<i}else{let s=t-this.header.numReadonlySignedAccounts;return e<s}}resolveAddressTableLookups(e){let t={writable:[],readonly:[]};for(let n of this.addressTableLookups){let s=e.find(o=>o.key.equals(n.accountKey));if(!s)throw new Error(`Failed to find address lookup table account for table key ${n.accountKey.toBase58()}`);for(let o of n.writableIndexes)if(o<s.state.addresses.length)t.writable.push(s.state.addresses[o]);else throw new Error(`Failed to find address for index ${o} in address lookup table ${n.accountKey.toBase58()}`);for(let o of n.readonlyIndexes)if(o<s.state.addresses.length)t.readonly.push(s.state.addresses[o]);else throw new Error(`Failed to find address for index ${o} in address lookup table ${n.accountKey.toBase58()}`)}return t}static compile(e){let t=rr.compile(e.instructions,e.payerKey),n=new Array,s={writable:new Array,readonly:new Array},o=e.addressLookupTableAccounts||[];for(let d of o){let _=t.extractTableLookup(d);if(_!==void 0){let[I,{writable:p,readonly:g}]=_;n.push(I),s.writable.push(...p),s.readonly.push(...g)}}let[i,a]=t.getMessageComponents(),l=new At(a,s).compileInstructions(e.instructions);return new r({header:i,staticAccountKeys:a,recentBlockhash:e.recentBlockhash,compiledInstructions:l,addressTableLookups:n})}serialize(){let e=Array();Be(e,this.staticAccountKeys.length);let t=this.serializeInstructions(),n=Array();Be(n,this.compiledInstructions.length);let s=this.serializeAddressTableLookups(),o=Array();Be(o,this.addressTableLookups.length);let i=u.struct([u.u8("prefix"),u.struct([u.u8("numRequiredSignatures"),u.u8("numReadonlySignedAccounts"),u.u8("numReadonlyUnsignedAccounts")],"header"),u.blob(e.length,"staticAccountKeysLength"),u.seq(K(),this.staticAccountKeys.length,"staticAccountKeys"),K("recentBlockhash"),u.blob(n.length,"instructionsLength"),u.blob(t.length,"serializedInstructions"),u.blob(o.length,"addressTableLookupsLength"),u.blob(s.length,"serializedAddressTableLookups")]),a=new Uint8Array(ht),l=i.encode({prefix:128,header:this.header,staticAccountKeysLength:new Uint8Array(e),staticAccountKeys:this.staticAccountKeys.map(d=>d.toBytes()),recentBlockhash:le.default.decode(this.recentBlockhash),instructionsLength:new Uint8Array(n),serializedInstructions:t,addressTableLookupsLength:new Uint8Array(o),serializedAddressTableLookups:s},a);return a.slice(0,l)}serializeInstructions(){let e=0,t=new Uint8Array(ht);for(let n of this.compiledInstructions){let s=Array();Be(s,n.accountKeyIndexes.length);let o=Array();Be(o,n.data.length);let i=u.struct([u.u8("programIdIndex"),u.blob(s.length,"encodedAccountKeyIndexesLength"),u.seq(u.u8(),n.accountKeyIndexes.length,"accountKeyIndexes"),u.blob(o.length,"encodedDataLength"),u.blob(n.data.length,"data")]);e+=i.encode({programIdIndex:n.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(s),accountKeyIndexes:n.accountKeyIndexes,encodedDataLength:new Uint8Array(o),data:n.data},t,e)}return t.slice(0,e)}serializeAddressTableLookups(){let e=0,t=new Uint8Array(ht);for(let n of this.addressTableLookups){let s=Array();Be(s,n.writableIndexes.length);let o=Array();Be(o,n.readonlyIndexes.length);let i=u.struct([K("accountKey"),u.blob(s.length,"encodedWritableIndexesLength"),u.seq(u.u8(),n.writableIndexes.length,"writableIndexes"),u.blob(o.length,"encodedReadonlyIndexesLength"),u.seq(u.u8(),n.readonlyIndexes.length,"readonlyIndexes")]);e+=i.encode({accountKey:n.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(s),writableIndexes:n.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(o),readonlyIndexes:n.readonlyIndexes},t,e)}return t.slice(0,e)}static deserialize(e){let t=[...e],n=je(t),s=n&fr;q(n!==s,"Expected versioned message but received legacy message");let o=s;q(o===0,`Expected versioned message with version 0 but found version ${o}`);let i={numRequiredSignatures:je(t),numReadonlySignedAccounts:je(t),numReadonlyUnsignedAccounts:je(t)},a=[],c=Ne(t);for(let g=0;g<c;g++)a.push(new w(Te(t,0,Je)));let l=le.default.encode(Te(t,0,Je)),d=Ne(t),_=[];for(let g=0;g<d;g++){let R=je(t),S=Ne(t),N=Te(t,0,S),M=Ne(t),Z=new Uint8Array(Te(t,0,M));_.push({programIdIndex:R,accountKeyIndexes:N,data:Z})}let I=Ne(t),p=[];for(let g=0;g<I;g++){let R=new w(Te(t,0,Je)),S=Ne(t),N=Te(t,0,S),M=Ne(t),Z=Te(t,0,M);p.push({accountKey:R,writableIndexes:N,readonlyIndexes:Z})}return new r({header:i,staticAccountKeys:a,recentBlockhash:l,compiledInstructions:_,addressTableLookups:p})}},Cs={deserializeMessageVersion(r){let e=r[0],t=e&fr;return t===e?"legacy":t},deserialize:r=>{let e=Cs.deserializeMessageVersion(r);if(e==="legacy")return Ze.from(r);if(e===0)return Pt.deserialize(r);throw new Error(`Transaction message version ${e} deserialization is not supported`)}},rt=function(r){return r[r.BLOCKHEIGHT_EXCEEDED=0]="BLOCKHEIGHT_EXCEEDED",r[r.PROCESSED=1]="PROCESSED",r[r.TIMED_OUT=2]="TIMED_OUT",r[r.NONCE_INVALID=3]="NONCE_INVALID",r}({}),zf=P.Buffer.alloc(rn).fill(0),X=class{constructor(e){this.keys=void 0,this.programId=void 0,this.data=P.Buffer.alloc(0),this.programId=e.programId,this.keys=e.keys,e.data&&(this.data=e.data)}toJSON(){return{keys:this.keys.map(({pubkey:e,isSigner:t,isWritable:n})=>({pubkey:e.toJSON(),isSigner:t,isWritable:n})),programId:this.programId.toJSON(),data:[...this.data]}}},Y=class r{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(e){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,!!e)if(e.feePayer&&(this.feePayer=e.feePayer),e.signatures&&(this.signatures=e.signatures),Object.prototype.hasOwnProperty.call(e,"nonceInfo")){let{minContextSlot:t,nonceInfo:n}=e;this.minNonceContextSlot=t,this.nonceInfo=n}else if(Object.prototype.hasOwnProperty.call(e,"lastValidBlockHeight")){let{blockhash:t,lastValidBlockHeight:n}=e;this.recentBlockhash=t,this.lastValidBlockHeight=n}else{let{recentBlockhash:t,nonceInfo:n}=e;n&&(this.nonceInfo=n),this.recentBlockhash=t}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map(e=>e.toJSON()),signers:this.signatures.map(({publicKey:e})=>e.toJSON())}}add(...e){if(e.length===0)throw new Error("No instructions");return e.forEach(t=>{"instructions"in t?this.instructions=this.instructions.concat(t.instructions):"data"in t&&"programId"in t&&"keys"in t?this.instructions.push(t):this.instructions.push(new X(t))}),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let e,t;if(this.nonceInfo?(e=this.nonceInfo.nonce,this.instructions[0]!=this.nonceInfo.nonceInstruction?t=[this.nonceInfo.nonceInstruction,...this.instructions]:t=this.instructions):(e=this.recentBlockhash,t=this.instructions),!e)throw new Error("Transaction recentBlockhash required");t.length<1&&console.warn("No instructions provided");let n;if(this.feePayer)n=this.feePayer;else if(this.signatures.length>0&&this.signatures[0].publicKey)n=this.signatures[0].publicKey;else throw new Error("Transaction fee payer required");for(let R=0;R<t.length;R++)if(t[R].programId===void 0)throw new Error(`Transaction instruction index ${R} has undefined program id`);let s=[],o=[];t.forEach(R=>{R.keys.forEach(N=>{o.push(C({},N))});let S=R.programId.toString();s.includes(S)||s.push(S)}),s.forEach(R=>{o.push({pubkey:new w(R),isSigner:!1,isWritable:!1})});let i=[];o.forEach(R=>{let S=R.pubkey.toString(),N=i.findIndex(M=>M.pubkey.toString()===S);N>-1?(i[N].isWritable=i[N].isWritable||R.isWritable,i[N].isSigner=i[N].isSigner||R.isSigner):i.push(R)}),i.sort(function(R,S){if(R.isSigner!==S.isSigner)return R.isSigner?-1:1;if(R.isWritable!==S.isWritable)return R.isWritable?-1:1;let N={localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"};return R.pubkey.toBase58().localeCompare(S.pubkey.toBase58(),"en",N)});let a=i.findIndex(R=>R.pubkey.equals(n));if(a>-1){let[R]=i.splice(a,1);R.isSigner=!0,R.isWritable=!0,i.unshift(R)}else i.unshift({pubkey:n,isSigner:!0,isWritable:!0});for(let R of this.signatures){let S=i.findIndex(N=>N.pubkey.equals(R.publicKey));if(S>-1)i[S].isSigner||(i[S].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));else throw new Error(`unknown signer: ${R.publicKey.toString()}`)}let c=0,l=0,d=0,_=[],I=[];i.forEach(({pubkey:R,isSigner:S,isWritable:N})=>{S?(_.push(R.toString()),c+=1,N||(l+=1)):(I.push(R.toString()),N||(d+=1))});let p=_.concat(I),g=t.map(R=>{let{data:S,programId:N}=R;return{programIdIndex:p.indexOf(N.toString()),accounts:R.keys.map(M=>p.indexOf(M.pubkey.toString())),data:le.default.encode(S)}});return g.forEach(R=>{q(R.programIdIndex>=0),R.accounts.forEach(S=>q(S>=0))}),new Ze({header:{numRequiredSignatures:c,numReadonlySignedAccounts:l,numReadonlyUnsignedAccounts:d},accountKeys:p,recentBlockhash:e,instructions:g})}_compile(){let e=this.compileMessage(),t=e.accountKeys.slice(0,e.header.numRequiredSignatures);return this.signatures.length===t.length&&this.signatures.every((s,o)=>t[o].equals(s.publicKey))||(this.signatures=t.map(n=>({signature:null,publicKey:n}))),e}serializeMessage(){return this._compile().serialize()}getEstimatedFee(e){return y(this,null,function*(){return(yield e.getFeeForMessage(this.compileMessage())).value})}setSigners(...e){if(e.length===0)throw new Error("No signers");let t=new Set;this.signatures=e.filter(n=>{let s=n.toString();return t.has(s)?!1:(t.add(s),!0)}).map(n=>({signature:null,publicKey:n}))}sign(...e){if(e.length===0)throw new Error("No signers");let t=new Set,n=[];for(let o of e){let i=o.publicKey.toString();t.has(i)||(t.add(i),n.push(o))}this.signatures=n.map(o=>({signature:null,publicKey:o.publicKey}));let s=this._compile();this._partialSign(s,...n)}partialSign(...e){if(e.length===0)throw new Error("No signers");let t=new Set,n=[];for(let o of e){let i=o.publicKey.toString();t.has(i)||(t.add(i),n.push(o))}let s=this._compile();this._partialSign(s,...n)}_partialSign(e,...t){let n=e.serialize();t.forEach(s=>{let o=vs(n,s.secretKey);this._addSignature(s.publicKey,z(o))})}addSignature(e,t){this._compile(),this._addSignature(e,t)}_addSignature(e,t){q(t.length===64);let n=this.signatures.findIndex(s=>e.equals(s.publicKey));if(n<0)throw new Error(`unknown signer: ${e.toString()}`);this.signatures[n].signature=P.Buffer.from(t)}verifySignatures(e=!0){return!this._getMessageSignednessErrors(this.serializeMessage(),e)}_getMessageSignednessErrors(e,t){let n={};for(let{signature:s,publicKey:o}of this.signatures)s===null?t&&(n.missing||=[]).push(o):Lf(s,e,o.toBytes())||(n.invalid||=[]).push(o);return n.invalid||n.missing?n:void 0}serialize(e){let{requireAllSignatures:t,verifySignatures:n}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},e),s=this.serializeMessage();if(n){let o=this._getMessageSignednessErrors(s,t);if(o){let i="Signature verification failed.";throw o.invalid&&(i+=`
Invalid signature for public key${o.invalid.length===1?"":"(s)"} [\`${o.invalid.map(a=>a.toBase58()).join("`, `")}\`].`),o.missing&&(i+=`
Missing signature for public key${o.missing.length===1?"":"(s)"} [\`${o.missing.map(a=>a.toBase58()).join("`, `")}\`].`),new Error(i)}}return this._serialize(s)}_serialize(e){let{signatures:t}=this,n=[];Be(n,t.length);let s=n.length+t.length*64+e.length,o=P.Buffer.alloc(s);return q(t.length<256),P.Buffer.from(n).copy(o,0),t.forEach(({signature:i},a)=>{i!==null&&(q(i.length===64,"signature has invalid length"),P.Buffer.from(i).copy(o,n.length+a*64))}),e.copy(o,n.length+t.length*64),q(o.length<=ht,`Transaction too large: ${o.length} > ${ht}`),o}get keys(){return q(this.instructions.length===1),this.instructions[0].keys.map(e=>e.pubkey)}get programId(){return q(this.instructions.length===1),this.instructions[0].programId}get data(){return q(this.instructions.length===1),this.instructions[0].data}static from(e){let t=[...e],n=Ne(t),s=[];for(let o=0;o<n;o++){let i=Te(t,0,rn);s.push(le.default.encode(P.Buffer.from(i)))}return r.populate(Ze.from(t),s)}static populate(e,t=[]){let n=new r;return n.recentBlockhash=e.recentBlockhash,e.header.numRequiredSignatures>0&&(n.feePayer=e.accountKeys[0]),t.forEach((s,o)=>{let i={signature:s==le.default.encode(zf)?null:le.default.decode(s),publicKey:e.accountKeys[o]};n.signatures.push(i)}),e.instructions.forEach(s=>{let o=s.accounts.map(i=>{let a=e.accountKeys[i];return{pubkey:a,isSigner:n.signatures.some(c=>c.publicKey.toString()===a.toString())||e.isAccountSigner(i),isWritable:e.isAccountWritable(i)}});n.instructions.push(new X({keys:o,programId:e.accountKeys[s.programIdIndex],data:le.default.decode(s.data)}))}),n._message=e,n._json=n.toJSON(),n}},hs=class r{constructor(e){this.payerKey=void 0,this.instructions=void 0,this.recentBlockhash=void 0,this.payerKey=e.payerKey,this.instructions=e.instructions,this.recentBlockhash=e.recentBlockhash}static decompile(e,t){let{header:n,compiledInstructions:s,recentBlockhash:o}=e,{numRequiredSignatures:i,numReadonlySignedAccounts:a,numReadonlyUnsignedAccounts:c}=n,l=i-a;q(l>0,"Message header is invalid");let d=e.staticAccountKeys.length-i-c;q(d>=0,"Message header is invalid");let _=e.getAccountKeys(t),I=_.get(0);if(I===void 0)throw new Error("Failed to decompile message because no account keys were found");let p=[];for(let g of s){let R=[];for(let N of g.accountKeyIndexes){let M=_.get(N);if(M===void 0)throw new Error(`Failed to find key for account key index ${N}`);let Z=N<i,v;Z?v=N<l:N<_.staticAccountKeys.length?v=N-i<d:v=N-_.staticAccountKeys.length<_.accountKeysFromLookups.writable.length,R.push({pubkey:M,isSigner:N<n.numRequiredSignatures,isWritable:v})}let S=_.get(g.programIdIndex);if(S===void 0)throw new Error(`Failed to find program id for program id index ${g.programIdIndex}`);p.push(new X({programId:S,data:z(g.data),keys:R}))}return new r({payerKey:I,instructions:p,recentBlockhash:o})}compileToLegacyMessage(){return Ze.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions})}compileToV0Message(e){return Pt.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions,addressLookupTableAccounts:e})}},_s=class r{get version(){return this.message.version}constructor(e,t){if(this.signatures=void 0,this.message=void 0,t!==void 0)q(t.length===e.header.numRequiredSignatures,"Expected signatures length to be equal to the number of required signatures"),this.signatures=t;else{let n=[];for(let s=0;s<e.header.numRequiredSignatures;s++)n.push(new Uint8Array(rn));this.signatures=n}this.message=e}serialize(){let e=this.message.serialize(),t=Array();Be(t,this.signatures.length);let n=u.struct([u.blob(t.length,"encodedSignaturesLength"),u.seq(Bf(),this.signatures.length,"signatures"),u.blob(e.length,"serializedMessage")]),s=new Uint8Array(2048),o=n.encode({encodedSignaturesLength:new Uint8Array(t),signatures:this.signatures,serializedMessage:e},s);return s.slice(0,o)}static deserialize(e){let t=[...e],n=[],s=Ne(t);for(let i=0;i<s;i++)n.push(new Uint8Array(Te(t,0,rn)));let o=Cs.deserialize(new Uint8Array(t));return new r(o,n)}sign(e){let t=this.message.serialize(),n=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures);for(let s of e){let o=n.findIndex(i=>i.equals(s.publicKey));q(o>=0,`Cannot sign with non signer key ${s.publicKey.toBase58()}`),this.signatures[o]=vs(t,s.secretKey)}}addSignature(e,t){q(t.byteLength===64,"Signature must be 64 bytes long");let s=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures).findIndex(o=>o.equals(e));q(s>=0,`Can not add signature; \`${e.toBase58()}\` is not required to sign this transaction`),this.signatures[s]=t}},Mf=160,Ff=64,Kf=Mf/Ff,xi=1e3/Kf,He=new w("SysvarC1ock11111111111111111111111111111111"),Wf=new w("SysvarEpochSchedu1e111111111111111111111111"),$f=new w("Sysvar1nstructions1111111111111111111111111"),er=new w("SysvarRecentB1ockHashes11111111111111111111"),Dt=new w("SysvarRent111111111111111111111111111111111"),Vf=new w("SysvarRewards111111111111111111111111111111"),Gf=new w("SysvarS1otHashes111111111111111111111111111"),qf=new w("SysvarS1otHistory11111111111111111111111111"),tr=new w("SysvarStakeHistory1111111111111111111111111"),It=class extends Error{constructor({action:e,signature:t,transactionMessage:n,logs:s}){let o=s?`Logs: 
${JSON.stringify(s.slice(-10),null,2)}. `:"",i="\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.",a;switch(e){case"send":a=`Transaction ${t} resulted in an error. 
${n}. `+o+i;break;case"simulate":a=`Simulation failed. 
Message: ${n}. 
`+o+i;break;default:a=`Unknown action '${(c=>c)(e)}'`}super(a),this.signature=void 0,this.transactionMessage=void 0,this.transactionLogs=void 0,this.signature=t,this.transactionMessage=n,this.transactionLogs=s||void 0}get transactionError(){return{message:this.transactionMessage,logs:Array.isArray(this.transactionLogs)?this.transactionLogs:void 0}}get logs(){let e=this.transactionLogs;if(!(e!=null&&typeof e=="object"&&"then"in e))return e}getLogs(e){return y(this,null,function*(){return Array.isArray(this.transactionLogs)||(this.transactionLogs=new Promise((t,n)=>{e.getTransaction(this.signature).then(s=>{if(s&&s.meta&&s.meta.logMessages){let o=s.meta.logMessages;this.transactionLogs=o,t(o)}else n(new Error("Log messages not found"))}).catch(n)})),yield this.transactionLogs})}},Hf={JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP:-32001,JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE:-32002,JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE:-32003,JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE:-32004,JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY:-32005,JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE:-32006,JSON_RPC_SERVER_ERROR_SLOT_SKIPPED:-32007,JSON_RPC_SERVER_ERROR_NO_SNAPSHOT:-32008,JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED:-32009,JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX:-32010,JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE:-32011,JSON_RPC_SCAN_ERROR:-32012,JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH:-32013,JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET:-32014,JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION:-32015,JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED:-32016},T=class extends Error{constructor({code:e,message:t,data:n},s){super(s!=null?`${s}: ${t}`:t),this.code=void 0,this.data=void 0,this.code=e,this.data=n,this.name="SolanaJSONRPCError"}};Pi=u.nu64("lamportsPerSignature"),Di=u.struct([u.u32("version"),u.u32("state"),K("authorizedPubkey"),K("nonce"),u.struct([Pi],"feeCalculator")]),ys=Di.span,sr=class r{constructor(e){this.authorizedPubkey=void 0,this.nonce=void 0,this.feeCalculator=void 0,this.authorizedPubkey=e.authorizedPubkey,this.nonce=e.nonce,this.feeCalculator=e.feeCalculator}static fromAccountData(e){let t=Di.decode(z(e),0);return new r({authorizedPubkey:new w(t.authorizedPubkey),nonce:new w(t.nonce).toString(),feeCalculator:t.feeCalculator})}};gs=class{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);let n=u.u32("instruction").decode(e.data),s;for(let[o,i]of Object.entries(ee))if(i.index==n){s=o;break}if(!s)throw new Error("Instruction type incorrect; not a SystemInstruction");return s}static decodeCreateAccount(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);let{lamports:t,space:n,programId:s}=j(ee.Create,e.data);return{fromPubkey:e.keys[0].pubkey,newAccountPubkey:e.keys[1].pubkey,lamports:t,space:n,programId:new w(s)}}static decodeTransfer(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);let{lamports:t}=j(ee.Transfer,e.data);return{fromPubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,lamports:t}}static decodeTransferWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);let{lamports:t,seed:n,programId:s}=j(ee.TransferWithSeed,e.data);return{fromPubkey:e.keys[0].pubkey,basePubkey:e.keys[1].pubkey,toPubkey:e.keys[2].pubkey,lamports:t,seed:n,programId:new w(s)}}static decodeAllocate(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);let{space:t}=j(ee.Allocate,e.data);return{accountPubkey:e.keys[0].pubkey,space:t}}static decodeAllocateWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);let{base:t,seed:n,space:s,programId:o}=j(ee.AllocateWithSeed,e.data);return{accountPubkey:e.keys[0].pubkey,basePubkey:new w(t),seed:n,space:s,programId:new w(o)}}static decodeAssign(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);let{programId:t}=j(ee.Assign,e.data);return{accountPubkey:e.keys[0].pubkey,programId:new w(t)}}static decodeAssignWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);let{base:t,seed:n,programId:s}=j(ee.AssignWithSeed,e.data);return{accountPubkey:e.keys[0].pubkey,basePubkey:new w(t),seed:n,programId:new w(s)}}static decodeCreateWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);let{base:t,seed:n,lamports:s,space:o,programId:i}=j(ee.CreateWithSeed,e.data);return{fromPubkey:e.keys[0].pubkey,newAccountPubkey:e.keys[1].pubkey,basePubkey:new w(t),seed:n,lamports:s,space:o,programId:new w(i)}}static decodeNonceInitialize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);let{authorized:t}=j(ee.InitializeNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,authorizedPubkey:new w(t)}}static decodeNonceAdvance(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),j(ee.AdvanceNonceAccount,e.data),{noncePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey}}static decodeNonceWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,5);let{lamports:t}=j(ee.WithdrawNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey,lamports:t}}static decodeNonceAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);let{authorized:t}=j(ee.AuthorizeNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[1].pubkey,newAuthorizedPubkey:new w(t)}}static checkProgramId(e){if(!e.equals(_e.programId))throw new Error("invalid instruction; programId is not SystemProgram")}static checkKeyLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}},ee=Object.freeze({Create:{index:0,layout:u.struct([u.u32("instruction"),u.ns64("lamports"),u.ns64("space"),K("programId")])},Assign:{index:1,layout:u.struct([u.u32("instruction"),K("programId")])},Transfer:{index:2,layout:u.struct([u.u32("instruction"),Ut("lamports")])},CreateWithSeed:{index:3,layout:u.struct([u.u32("instruction"),K("base"),bt("seed"),u.ns64("lamports"),u.ns64("space"),K("programId")])},AdvanceNonceAccount:{index:4,layout:u.struct([u.u32("instruction")])},WithdrawNonceAccount:{index:5,layout:u.struct([u.u32("instruction"),u.ns64("lamports")])},InitializeNonceAccount:{index:6,layout:u.struct([u.u32("instruction"),K("authorized")])},AuthorizeNonceAccount:{index:7,layout:u.struct([u.u32("instruction"),K("authorized")])},Allocate:{index:8,layout:u.struct([u.u32("instruction"),u.ns64("space")])},AllocateWithSeed:{index:9,layout:u.struct([u.u32("instruction"),K("base"),bt("seed"),u.ns64("space"),K("programId")])},AssignWithSeed:{index:10,layout:u.struct([u.u32("instruction"),K("base"),bt("seed"),K("programId")])},TransferWithSeed:{index:11,layout:u.struct([u.u32("instruction"),Ut("lamports"),bt("seed"),K("programId")])},UpgradeNonceAccount:{index:12,layout:u.struct([u.u32("instruction")])}}),_e=class r{constructor(){}static createAccount(e){let t=ee.Create,n=$(t,{lamports:e.lamports,space:e.space,programId:z(e.programId.toBuffer())});return new X({keys:[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!0,isWritable:!0}],programId:this.programId,data:n})}static transfer(e){let t,n;if("basePubkey"in e){let s=ee.TransferWithSeed;t=$(s,{lamports:BigInt(e.lamports),seed:e.seed,programId:z(e.programId.toBuffer())}),n=[{pubkey:e.fromPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}else{let s=ee.Transfer;t=$(s,{lamports:BigInt(e.lamports)}),n=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}return new X({keys:n,programId:this.programId,data:t})}static assign(e){let t,n;if("basePubkey"in e){let s=ee.AssignWithSeed;t=$(s,{base:z(e.basePubkey.toBuffer()),seed:e.seed,programId:z(e.programId.toBuffer())}),n=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{let s=ee.Assign;t=$(s,{programId:z(e.programId.toBuffer())}),n=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new X({keys:n,programId:this.programId,data:t})}static createAccountWithSeed(e){let t=ee.CreateWithSeed,n=$(t,{base:z(e.basePubkey.toBuffer()),seed:e.seed,lamports:e.lamports,space:e.space,programId:z(e.programId.toBuffer())}),s=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!1,isWritable:!0}];return e.basePubkey.equals(e.fromPubkey)||s.push({pubkey:e.basePubkey,isSigner:!0,isWritable:!1}),new X({keys:s,programId:this.programId,data:n})}static createNonceAccount(e){let t=new Y;"basePubkey"in e&&"seed"in e?t.add(r.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:ys,programId:this.programId})):t.add(r.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,lamports:e.lamports,space:ys,programId:this.programId}));let n={noncePubkey:e.noncePubkey,authorizedPubkey:e.authorizedPubkey};return t.add(this.nonceInitialize(n)),t}static nonceInitialize(e){let t=ee.InitializeNonceAccount,n=$(t,{authorized:z(e.authorizedPubkey.toBuffer())}),s={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:er,isSigner:!1,isWritable:!1},{pubkey:Dt,isSigner:!1,isWritable:!1}],programId:this.programId,data:n};return new X(s)}static nonceAdvance(e){let t=ee.AdvanceNonceAccount,n=$(t),s={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:er,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:n};return new X(s)}static nonceWithdraw(e){let t=ee.WithdrawNonceAccount,n=$(t,{lamports:e.lamports});return new X({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0},{pubkey:er,isSigner:!1,isWritable:!1},{pubkey:Dt,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:n})}static nonceAuthorize(e){let t=ee.AuthorizeNonceAccount,n=$(t,{authorized:z(e.newAuthorizedPubkey.toBuffer())});return new X({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:n})}static allocate(e){let t,n;if("basePubkey"in e){let s=ee.AllocateWithSeed;t=$(s,{base:z(e.basePubkey.toBuffer()),seed:e.seed,space:e.space,programId:z(e.programId.toBuffer())}),n=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{let s=ee.Allocate;t=$(s,{space:e.space}),n=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new X({keys:n,programId:this.programId,data:t})}};_e.programId=new w("11111111111111111111111111111111");jf=ht-300,Rs=(()=>{class r{constructor(){}static getMinNumSignatures(t){return 2*(Math.ceil(t/r.chunkSize)+1+1)}static load(t,n,s,o,i){return y(this,null,function*(){{let I=yield t.getMinimumBalanceForRentExemption(i.length),p=yield t.getAccountInfo(s.publicKey,"confirmed"),g=null;if(p!==null){if(p.executable)return console.error("Program load failed, account is already executable"),!1;p.data.length!==i.length&&(g=g||new Y,g.add(_e.allocate({accountPubkey:s.publicKey,space:i.length}))),p.owner.equals(o)||(g=g||new Y,g.add(_e.assign({accountPubkey:s.publicKey,programId:o}))),p.lamports<I&&(g=g||new Y,g.add(_e.transfer({fromPubkey:n.publicKey,toPubkey:s.publicKey,lamports:I-p.lamports})))}else g=new Y().add(_e.createAccount({fromPubkey:n.publicKey,newAccountPubkey:s.publicKey,lamports:I>0?I:1,space:i.length,programId:o}));g!==null&&(yield ps(t,g,[n,s],{commitment:"confirmed"}))}let a=u.struct([u.u32("instruction"),u.u32("offset"),u.u32("bytesLength"),u.u32("bytesLengthPadding"),u.seq(u.u8("byte"),u.offset(u.u32(),-8),"bytes")]),c=r.chunkSize,l=0,d=i,_=[];for(;d.length>0;){let I=d.slice(0,c),p=P.Buffer.alloc(c+16);a.encode({instruction:0,offset:l,bytes:I,bytesLength:0,bytesLengthPadding:0},p);let g=new Y().add({keys:[{pubkey:s.publicKey,isSigner:!0,isWritable:!0}],programId:o,data:p});_.push(ps(t,g,[n,s],{commitment:"confirmed"})),t._rpcEndpoint.includes("solana.com")&&(yield Et(1e3/4)),l+=c,d=d.slice(c)}yield Promise.all(_);{let I=u.struct([u.u32("instruction")]),p=P.Buffer.alloc(I.span);I.encode({instruction:1},p);let g=new Y().add({keys:[{pubkey:s.publicKey,isSigner:!0,isWritable:!0},{pubkey:Dt,isSigner:!1,isWritable:!1}],programId:o,data:p}),R="processed",S=yield t.sendTransaction(g,[n,s],{preflightCommitment:R}),{context:N,value:M}=yield t.confirmTransaction({signature:S,lastValidBlockHeight:g.lastValidBlockHeight,blockhash:g.recentBlockhash},R);if(M.err)throw new Error(`Transaction ${S} failed (${JSON.stringify(M)})`);for(;;){try{if((yield t.getSlot({commitment:R}))>N.slot)break}catch{}yield new Promise(Z=>setTimeout(Z,Math.round(xi/2)))}}return!0})}}return r.chunkSize=jf,r})(),Yf=new w("BPFLoader2111111111111111111111111111111111"),ms=class{static getMinNumSignatures(e){return Rs.getMinNumSignatures(e)}static load(e,t,n,s,o){return Rs.load(e,t,n,o,s)}};Zf=Jf(),_i=Xf(Zf),en=32;or=class{constructor(e,t,n,s,o){this.slotsPerEpoch=void 0,this.leaderScheduleSlotOffset=void 0,this.warmup=void 0,this.firstNormalEpoch=void 0,this.firstNormalSlot=void 0,this.slotsPerEpoch=e,this.leaderScheduleSlotOffset=t,this.warmup=n,this.firstNormalEpoch=s,this.firstNormalSlot=o}getEpoch(e){return this.getEpochAndSlotIndex(e)[0]}getEpochAndSlotIndex(e){if(e<this.firstNormalSlot){let t=os(Qf(e+en+1))-os(en)-1,n=this.getSlotsInEpoch(t),s=e-(n-en);return[t,s]}else{let t=e-this.firstNormalSlot,n=Math.floor(t/this.slotsPerEpoch),s=this.firstNormalEpoch+n,o=t%this.slotsPerEpoch;return[s,o]}}getFirstSlotInEpoch(e){return e<=this.firstNormalEpoch?(Math.pow(2,e)-1)*en:(e-this.firstNormalEpoch)*this.slotsPerEpoch+this.firstNormalSlot}getLastSlotInEpoch(e){return this.getFirstSlotInEpoch(e)+this.getSlotsInEpoch(e)-1}getSlotsInEpoch(e){return e<this.firstNormalEpoch?Math.pow(2,e+os(en)):this.slotsPerEpoch}},eh=globalThis.fetch,Ss=class extends ci{constructor(e,t,n){let s=o=>{let i=ai(o,C({autoconnect:!0,max_reconnects:5,reconnect:!0,reconnect_interval:1e3},t));return"socket"in i?this.underlyingSocket=i.socket:this.underlyingSocket=i,i};super(s,e,t,n),this.underlyingSocket=void 0}call(...e){let t=this.underlyingSocket?.readyState;return t===1?super.call(...e):Promise.reject(new Error("Tried to call a JSON-RPC method `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+t+")"))}notify(...e){let t=this.underlyingSocket?.readyState;return t===1?super.notify(...e):Promise.reject(new Error("Tried to send a JSON-RPC notification `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+t+")"))}};pi=56,an=class{constructor(e){this.key=void 0,this.state=void 0,this.key=e.key,this.state=e.state}isActive(){let e=BigInt("0xffffffffffffffff");return this.state.deactivationSlot===e}static deserialize(e){let t=th(nh,e),n=e.length-pi;q(n>=0,"lookup table is invalid"),q(n%32===0,"lookup table is invalid");let s=n/32,{addresses:o}=u.struct([u.seq(K(),s,"addresses")]).decode(e.slice(pi));return{deactivationSlot:t.deactivationSlot,lastExtendedSlot:t.lastExtendedSlot,lastExtendedSlotStartIndex:t.lastExtendedStartIndex,authority:t.authority.length!==0?new w(t.authority[0]):void 0,addresses:o.map(i=>new w(i))}}},nh={index:1,layout:u.struct([u.u32("typeIndex"),Ut("deactivationSlot"),u.nu64("lastExtendedSlot"),u.u8("lastExtendedStartIndex"),u.u8(),u.seq(K(),u.offset(u.u8(),-1),"authority")])},rh=/^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;oe=xt(Vn(w),E(),r=>new w(r)),Ui=Gn([E(),re("base64")]),Bs=xt(Vn(P.Buffer),Ui,r=>P.Buffer.from(r[0],"base64")),zi=30*1e3;ih=Mi(St());ah=m({foundation:f(),foundationTerm:f(),initial:f(),taper:f(),terminal:f()}),ch=U(O(k(m({epoch:f(),effectiveSlot:f(),amount:f(),postBalance:f(),commission:B(k(f()))})))),uh=O(m({slot:f(),prioritizationFee:f()})),dh=m({total:f(),validator:f(),foundation:f(),epoch:f()}),lh=m({epoch:f(),slotIndex:f(),slotsInEpoch:f(),absoluteSlot:f(),blockHeight:B(f()),transactionCount:B(f())}),fh=m({slotsPerEpoch:f(),leaderScheduleSlotOffset:f(),warmup:Fe(),firstNormalEpoch:f(),firstNormalSlot:f()}),hh=Hr(E(),O(f())),Ot=k(Re([m({}),E()])),_h=m({err:Ot}),ph=re("receivedSignature"),yh=m({"solana-core":E(),"feature-set":B(f())}),gh=m({program:E(),programId:oe,parsed:St()}),Rh=m({programId:oe,accounts:O(oe),data:E()}),gi=ie(m({err:k(Re([m({}),E()])),logs:k(O(E())),accounts:B(k(O(k(m({executable:Fe(),owner:E(),lamports:f(),data:O(E()),rentEpoch:B(f())}))))),unitsConsumed:B(f()),returnData:B(k(m({programId:E(),data:Gn([E(),re("base64")])}))),innerInstructions:B(k(O(m({index:f(),instructions:O(Re([gh,Rh]))}))))})),mh=ie(m({byIdentity:Hr(E(),O(f())),range:m({firstSlot:f(),lastSlot:f()})}));Ah=U(ah),Ih=U(dh),wh=U(uh),Oh=U(lh),kh=U(fh),Nh=U(hh),Th=U(f()),Lh=ie(m({total:f(),circulating:f(),nonCirculating:f(),nonCirculatingAccounts:O(oe)})),Es=m({amount:E(),uiAmount:k(f()),decimals:f(),uiAmountString:B(E())}),vh=ie(O(m({address:oe,amount:E(),uiAmount:k(f()),decimals:f(),uiAmountString:B(E())}))),Ch=ie(O(m({pubkey:oe,account:m({executable:Fe(),owner:oe,lamports:f(),data:Bs,rentEpoch:f()})}))),bs=m({program:E(),parsed:St(),space:f()}),Bh=ie(O(m({pubkey:oe,account:m({executable:Fe(),owner:oe,lamports:f(),data:bs,rentEpoch:f()})}))),xh=ie(O(m({lamports:f(),address:oe}))),cn=m({executable:Fe(),owner:oe,lamports:f(),data:Bs,rentEpoch:f()}),Ph=m({pubkey:oe,account:cn}),Dh=xt(Re([Vn(P.Buffer),bs]),Re([Ui,bs]),r=>Array.isArray(r)?A(r,Bs):r),As=m({executable:Fe(),owner:oe,lamports:f(),data:Dh,rentEpoch:f()}),Uh=m({pubkey:oe,account:As}),zh=m({state:Re([re("active"),re("inactive"),re("activating"),re("deactivating")]),active:f(),inactive:f()}),Mh=U(O(m({signature:E(),slot:f(),err:Ot,memo:k(E()),blockTime:B(k(f()))}))),Fh=U(O(m({signature:E(),slot:f(),err:Ot,memo:k(E()),blockTime:B(k(f()))}))),Kh=m({subscription:f(),result:hr(cn)}),Wh=m({pubkey:oe,account:cn}),$h=m({subscription:f(),result:hr(Wh)}),Vh=m({parent:f(),slot:f(),root:f()}),Gh=m({subscription:f(),result:Vh}),qh=Re([m({type:Re([re("firstShredReceived"),re("completed"),re("optimisticConfirmation"),re("root")]),slot:f(),timestamp:f()}),m({type:re("createdBank"),parent:f(),slot:f(),timestamp:f()}),m({type:re("frozen"),slot:f(),timestamp:f(),stats:m({numTransactionEntries:f(),numSuccessfulTransactions:f(),numFailedTransactions:f(),maxTransactionsPerEntry:f()})}),m({type:re("dead"),slot:f(),timestamp:f(),err:E()})]),Hh=m({subscription:f(),result:qh}),jh=m({subscription:f(),result:hr(Re([_h,ph]))}),Yh=m({subscription:f(),result:f()}),Xh=m({pubkey:E(),gossip:k(E()),tpu:k(E()),rpc:k(E()),version:k(E())}),Ri=m({votePubkey:E(),nodePubkey:E(),activatedStake:f(),epochVoteAccount:Fe(),epochCredits:O(Gn([f(),f(),f()])),commission:f(),lastVote:f(),rootSlot:k(f())}),Jh=U(m({current:O(Ri),delinquent:O(Ri)})),Zh=Re([re("processed"),re("confirmed"),re("finalized")]),Qh=m({slot:f(),confirmations:k(f()),err:Ot,confirmationStatus:B(Zh)}),e_=ie(O(k(Qh))),t_=U(f()),Fi=m({accountKey:oe,writableIndexes:O(f()),readonlyIndexes:O(f())}),xs=m({signatures:O(E()),message:m({accountKeys:O(E()),header:m({numRequiredSignatures:f(),numReadonlySignedAccounts:f(),numReadonlyUnsignedAccounts:f()}),instructions:O(m({accounts:O(f()),data:E(),programIdIndex:f()})),recentBlockhash:E(),addressTableLookups:B(O(Fi))})}),Ki=m({pubkey:oe,signer:Fe(),writable:Fe(),source:B(Re([re("transaction"),re("lookupTable")]))}),Wi=m({accountKeys:O(Ki),signatures:O(E())}),$i=m({parsed:St(),program:E(),programId:oe}),Vi=m({accounts:O(oe),data:E(),programId:oe}),n_=Re([Vi,$i]),r_=Re([m({parsed:St(),program:E(),programId:E()}),m({accounts:O(E()),data:E(),programId:E()})]),Gi=xt(n_,r_,r=>"accounts"in r?A(r,Vi):A(r,$i)),qi=m({signatures:O(E()),message:m({accountKeys:O(Ki),instructions:O(Gi),recentBlockhash:E(),addressTableLookups:B(k(O(Fi)))})}),ir=m({accountIndex:f(),mint:E(),owner:B(E()),programId:B(E()),uiTokenAmount:Es}),Hi=m({writable:O(oe),readonly:O(oe)}),_r=m({err:Ot,fee:f(),innerInstructions:B(k(O(m({index:f(),instructions:O(m({accounts:O(f()),data:E(),programIdIndex:f()}))})))),preBalances:O(f()),postBalances:O(f()),logMessages:B(k(O(E()))),preTokenBalances:B(k(O(ir))),postTokenBalances:B(k(O(ir))),loadedAddresses:B(Hi),computeUnitsConsumed:B(f())}),Ps=m({err:Ot,fee:f(),innerInstructions:B(k(O(m({index:f(),instructions:O(Gi)})))),preBalances:O(f()),postBalances:O(f()),logMessages:B(k(O(E()))),preTokenBalances:B(k(O(ir))),postTokenBalances:B(k(O(ir))),loadedAddresses:B(Hi),computeUnitsConsumed:B(f())}),Kt=Re([re(0),re("legacy")]),kt=m({pubkey:E(),lamports:f(),postBalance:k(f()),rewardType:k(E()),commission:B(k(f()))}),s_=U(k(m({blockhash:E(),previousBlockhash:E(),parentSlot:f(),transactions:O(m({transaction:xs,meta:k(_r),version:B(Kt)})),rewards:B(O(kt)),blockTime:k(f()),blockHeight:k(f())}))),o_=U(k(m({blockhash:E(),previousBlockhash:E(),parentSlot:f(),rewards:B(O(kt)),blockTime:k(f()),blockHeight:k(f())}))),i_=U(k(m({blockhash:E(),previousBlockhash:E(),parentSlot:f(),transactions:O(m({transaction:Wi,meta:k(_r),version:B(Kt)})),rewards:B(O(kt)),blockTime:k(f()),blockHeight:k(f())}))),a_=U(k(m({blockhash:E(),previousBlockhash:E(),parentSlot:f(),transactions:O(m({transaction:qi,meta:k(Ps),version:B(Kt)})),rewards:B(O(kt)),blockTime:k(f()),blockHeight:k(f())}))),c_=U(k(m({blockhash:E(),previousBlockhash:E(),parentSlot:f(),transactions:O(m({transaction:Wi,meta:k(Ps),version:B(Kt)})),rewards:B(O(kt)),blockTime:k(f()),blockHeight:k(f())}))),u_=U(k(m({blockhash:E(),previousBlockhash:E(),parentSlot:f(),rewards:B(O(kt)),blockTime:k(f()),blockHeight:k(f())}))),d_=U(k(m({blockhash:E(),previousBlockhash:E(),parentSlot:f(),transactions:O(m({transaction:xs,meta:k(_r)})),rewards:B(O(kt)),blockTime:k(f())}))),mi=U(k(m({blockhash:E(),previousBlockhash:E(),parentSlot:f(),signatures:O(E()),blockTime:k(f())}))),as=U(k(m({slot:f(),meta:k(_r),blockTime:B(k(f())),transaction:xs,version:B(Kt)}))),Qn=U(k(m({slot:f(),transaction:qi,meta:k(Ps),blockTime:B(k(f())),version:B(Kt)}))),l_=ie(m({blockhash:E(),lastValidBlockHeight:f()})),f_=ie(Fe()),h_=m({slot:f(),numTransactions:f(),numSlots:f(),samplePeriodSecs:f()}),__=U(O(h_)),p_=ie(k(m({feeCalculator:m({lamportsPerSignature:f()})}))),y_=U(E()),g_=U(E()),R_=m({err:Ot,logs:O(E()),signature:E()}),m_=m({result:hr(R_),subscription:f()}),S_={"solana-client":"js/1.0.0-maintenance"},Is=class{constructor(e,t){this._commitment=void 0,this._confirmTransactionInitialTimeout=void 0,this._rpcEndpoint=void 0,this._rpcWsEndpoint=void 0,this._rpcClient=void 0,this._rpcRequest=void 0,this._rpcBatchRequest=void 0,this._rpcWebSocket=void 0,this._rpcWebSocketConnected=!1,this._rpcWebSocketHeartbeat=null,this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketGeneration=0,this._disableBlockhashCaching=!1,this._pollingBlockhash=!1,this._blockhashInfo={latestBlockhash:null,lastFetch:0,transactionSignatures:[],simulatedSignatures:[]},this._nextClientSubscriptionId=0,this._subscriptionDisposeFunctionsByClientSubscriptionId={},this._subscriptionHashByClientSubscriptionId={},this._subscriptionStateChangeCallbacksByHash={},this._subscriptionCallbacksByServerSubscriptionId={},this._subscriptionsByHash={},this._subscriptionsAutoDisposedByRpc=new Set,this.getBlockHeight=(()=>{let l={};return d=>y(this,null,function*(){let{commitment:_,config:I}=Q(d),p=this._buildArgs([],_,void 0,I),g=_i(p);return l[g]=l[g]??y(this,null,function*(){try{let R=yield this._rpcRequest("getBlockHeight",p),S=A(R,U(f()));if("error"in S)throw new T(S.error,"failed to get block height information");return S.result}finally{delete l[g]}}),yield l[g]})})();let n,s,o,i,a,c;t&&typeof t=="string"?this._commitment=t:t&&(this._commitment=t.commitment,this._confirmTransactionInitialTimeout=t.confirmTransactionInitialTimeout,n=t.wsEndpoint,s=t.httpHeaders,o=t.fetch,i=t.fetchMiddleware,a=t.disableRetryOnRateLimit,c=t.httpAgent),this._rpcEndpoint=oh(e),this._rpcWsEndpoint=n||sh(e),this._rpcClient=Sh(e,s,o,i,a,c),this._rpcRequest=Eh(this._rpcClient),this._rpcBatchRequest=bh(this._rpcClient),this._rpcWebSocket=new Ss(this._rpcWsEndpoint,{autoconnect:!1,max_reconnects:1/0}),this._rpcWebSocket.on("open",this._wsOnOpen.bind(this)),this._rpcWebSocket.on("error",this._wsOnError.bind(this)),this._rpcWebSocket.on("close",this._wsOnClose.bind(this)),this._rpcWebSocket.on("accountNotification",this._wsOnAccountNotification.bind(this)),this._rpcWebSocket.on("programNotification",this._wsOnProgramAccountNotification.bind(this)),this._rpcWebSocket.on("slotNotification",this._wsOnSlotNotification.bind(this)),this._rpcWebSocket.on("slotsUpdatesNotification",this._wsOnSlotUpdatesNotification.bind(this)),this._rpcWebSocket.on("signatureNotification",this._wsOnSignatureNotification.bind(this)),this._rpcWebSocket.on("rootNotification",this._wsOnRootNotification.bind(this)),this._rpcWebSocket.on("logsNotification",this._wsOnLogsNotification.bind(this))}get commitment(){return this._commitment}get rpcEndpoint(){return this._rpcEndpoint}getBalanceAndContext(e,t){return y(this,null,function*(){let{commitment:n,config:s}=Q(t),o=this._buildArgs([e.toBase58()],n,void 0,s),i=yield this._rpcRequest("getBalance",o),a=A(i,ie(f()));if("error"in a)throw new T(a.error,`failed to get balance for ${e.toBase58()}`);return a.result})}getBalance(e,t){return y(this,null,function*(){return yield this.getBalanceAndContext(e,t).then(n=>n.value).catch(n=>{throw new Error("failed to get balance of account "+e.toBase58()+": "+n)})})}getBlockTime(e){return y(this,null,function*(){let t=yield this._rpcRequest("getBlockTime",[e]),n=A(t,U(k(f())));if("error"in n)throw new T(n.error,`failed to get block time for slot ${e}`);return n.result})}getMinimumLedgerSlot(){return y(this,null,function*(){let e=yield this._rpcRequest("minimumLedgerSlot",[]),t=A(e,U(f()));if("error"in t)throw new T(t.error,"failed to get minimum ledger slot");return t.result})}getFirstAvailableBlock(){return y(this,null,function*(){let e=yield this._rpcRequest("getFirstAvailableBlock",[]),t=A(e,Th);if("error"in t)throw new T(t.error,"failed to get first available block");return t.result})}getSupply(e){return y(this,null,function*(){let t={};typeof e=="string"?t={commitment:e}:e?t=F(C({},e),{commitment:e&&e.commitment||this.commitment}):t={commitment:this.commitment};let n=yield this._rpcRequest("getSupply",[t]),s=A(n,Lh);if("error"in s)throw new T(s.error,"failed to get supply");return s.result})}getTokenSupply(e,t){return y(this,null,function*(){let n=this._buildArgs([e.toBase58()],t),s=yield this._rpcRequest("getTokenSupply",n),o=A(s,ie(Es));if("error"in o)throw new T(o.error,"failed to get token supply");return o.result})}getTokenAccountBalance(e,t){return y(this,null,function*(){let n=this._buildArgs([e.toBase58()],t),s=yield this._rpcRequest("getTokenAccountBalance",n),o=A(s,ie(Es));if("error"in o)throw new T(o.error,"failed to get token account balance");return o.result})}getTokenAccountsByOwner(e,t,n){return y(this,null,function*(){let{commitment:s,config:o}=Q(n),i=[e.toBase58()];"mint"in t?i.push({mint:t.mint.toBase58()}):i.push({programId:t.programId.toBase58()});let a=this._buildArgs(i,s,"base64",o),c=yield this._rpcRequest("getTokenAccountsByOwner",a),l=A(c,Ch);if("error"in l)throw new T(l.error,`failed to get token accounts owned by account ${e.toBase58()}`);return l.result})}getParsedTokenAccountsByOwner(e,t,n){return y(this,null,function*(){let s=[e.toBase58()];"mint"in t?s.push({mint:t.mint.toBase58()}):s.push({programId:t.programId.toBase58()});let o=this._buildArgs(s,n,"jsonParsed"),i=yield this._rpcRequest("getTokenAccountsByOwner",o),a=A(i,Bh);if("error"in a)throw new T(a.error,`failed to get token accounts owned by account ${e.toBase58()}`);return a.result})}getLargestAccounts(e){return y(this,null,function*(){let t=F(C({},e),{commitment:e&&e.commitment||this.commitment}),n=t.filter||t.commitment?[t]:[],s=yield this._rpcRequest("getLargestAccounts",n),o=A(s,xh);if("error"in o)throw new T(o.error,"failed to get largest accounts");return o.result})}getTokenLargestAccounts(e,t){return y(this,null,function*(){let n=this._buildArgs([e.toBase58()],t),s=yield this._rpcRequest("getTokenLargestAccounts",n),o=A(s,vh);if("error"in o)throw new T(o.error,"failed to get token largest accounts");return o.result})}getAccountInfoAndContext(e,t){return y(this,null,function*(){let{commitment:n,config:s}=Q(t),o=this._buildArgs([e.toBase58()],n,"base64",s),i=yield this._rpcRequest("getAccountInfo",o),a=A(i,ie(k(cn)));if("error"in a)throw new T(a.error,`failed to get info about account ${e.toBase58()}`);return a.result})}getParsedAccountInfo(e,t){return y(this,null,function*(){let{commitment:n,config:s}=Q(t),o=this._buildArgs([e.toBase58()],n,"jsonParsed",s),i=yield this._rpcRequest("getAccountInfo",o),a=A(i,ie(k(As)));if("error"in a)throw new T(a.error,`failed to get info about account ${e.toBase58()}`);return a.result})}getAccountInfo(e,t){return y(this,null,function*(){try{return(yield this.getAccountInfoAndContext(e,t)).value}catch(n){throw new Error("failed to get info about account "+e.toBase58()+": "+n)}})}getMultipleParsedAccounts(e,t){return y(this,null,function*(){let{commitment:n,config:s}=Q(t),o=e.map(l=>l.toBase58()),i=this._buildArgs([o],n,"jsonParsed",s),a=yield this._rpcRequest("getMultipleAccounts",i),c=A(a,ie(O(k(As))));if("error"in c)throw new T(c.error,`failed to get info for accounts ${o}`);return c.result})}getMultipleAccountsInfoAndContext(e,t){return y(this,null,function*(){let{commitment:n,config:s}=Q(t),o=e.map(l=>l.toBase58()),i=this._buildArgs([o],n,"base64",s),a=yield this._rpcRequest("getMultipleAccounts",i),c=A(a,ie(O(k(cn))));if("error"in c)throw new T(c.error,`failed to get info for accounts ${o}`);return c.result})}getMultipleAccountsInfo(e,t){return y(this,null,function*(){return(yield this.getMultipleAccountsInfoAndContext(e,t)).value})}getStakeActivation(e,t,n){return y(this,null,function*(){let{commitment:s,config:o}=Q(t),i=this._buildArgs([e.toBase58()],s,void 0,F(C({},o),{epoch:n??o?.epoch})),a=yield this._rpcRequest("getStakeActivation",i),c=A(a,U(zh));if("error"in c)throw new T(c.error,`failed to get Stake Activation ${e.toBase58()}`);return c.result})}getProgramAccounts(e,t){return y(this,null,function*(){let{commitment:n,config:s}=Q(t),_=s||{},{encoding:o}=_,i=De(_,["encoding"]),a=this._buildArgs([e.toBase58()],n,o||"base64",C(C({},i),i.filters?{filters:yi(i.filters)}:null)),c=yield this._rpcRequest("getProgramAccounts",a),l=O(Ph),d=i.withContext===!0?A(c,ie(l)):A(c,U(l));if("error"in d)throw new T(d.error,`failed to get accounts owned by program ${e.toBase58()}`);return d.result})}getParsedProgramAccounts(e,t){return y(this,null,function*(){let{commitment:n,config:s}=Q(t),o=this._buildArgs([e.toBase58()],n,"jsonParsed",s),i=yield this._rpcRequest("getProgramAccounts",o),a=A(i,U(O(Uh)));if("error"in a)throw new T(a.error,`failed to get accounts owned by program ${e.toBase58()}`);return a.result})}confirmTransaction(e,t){return y(this,null,function*(){let n;if(typeof e=="string")n=e;else{let o=e;if(o.abortSignal?.aborted)return Promise.reject(o.abortSignal.reason);n=o.signature}let s;try{s=le.default.decode(n)}catch{throw new Error("signature must be base58 encoded: "+n)}return q(s.length===64,"signature has invalid length"),typeof e=="string"?yield this.confirmTransactionUsingLegacyTimeoutStrategy({commitment:t||this.commitment,signature:n}):"lastValidBlockHeight"in e?yield this.confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:t||this.commitment,strategy:e}):yield this.confirmTransactionUsingDurableNonceStrategy({commitment:t||this.commitment,strategy:e})})}getCancellationPromise(e){return new Promise((t,n)=>{e!=null&&(e.aborted?n(e.reason):e.addEventListener("abort",()=>{n(e.reason)}))})}getTransactionConfirmationPromise({commitment:e,signature:t}){let n,s,o=!1,i=new Promise((c,l)=>{try{n=this.onSignature(t,(_,I)=>{n=void 0;let p={context:I,value:_};c({__type:rt.PROCESSED,response:p})},e);let d=new Promise(_=>{n==null?_():s=this._onSubscriptionStateChange(n,I=>{I==="subscribed"&&_()})});y(this,null,function*(){if(yield d,o)return;let _=yield this.getSignatureStatus(t);if(o||_==null)return;let{context:I,value:p}=_;if(p!=null)if(p?.err)l(p.err);else{switch(e){case"confirmed":case"single":case"singleGossip":{if(p.confirmationStatus==="processed")return;break}case"finalized":case"max":case"root":{if(p.confirmationStatus==="processed"||p.confirmationStatus==="confirmed")return;break}case"processed":case"recent":}o=!0,c({__type:rt.PROCESSED,response:{context:I,value:p}})}})}catch(d){l(d)}});return{abortConfirmation:()=>{s&&(s(),s=void 0),n!=null&&(this.removeSignatureListener(n),n=void 0)},confirmationPromise:i}}confirmTransactionUsingBlockHeightExceedanceStrategy(o){return y(this,arguments,function*({commitment:e,strategy:{abortSignal:t,lastValidBlockHeight:n,signature:s}}){let i=!1,a=new Promise(I=>{let p=()=>y(this,null,function*(){try{return yield this.getBlockHeight(e)}catch{return-1}});y(this,null,function*(){let g=yield p();if(!i){for(;g<=n;)if(yield Et(1e3),i||(g=yield p(),i))return;I({__type:rt.BLOCKHEIGHT_EXCEEDED})}})}),{abortConfirmation:c,confirmationPromise:l}=this.getTransactionConfirmationPromise({commitment:e,signature:s}),d=this.getCancellationPromise(t),_;try{let I=yield Promise.race([d,l,a]);if(I.__type===rt.PROCESSED)_=I.response;else throw new sn(s)}finally{i=!0,c()}return _})}confirmTransactionUsingDurableNonceStrategy(a){return y(this,arguments,function*({commitment:e,strategy:{abortSignal:t,minContextSlot:n,nonceAccountPubkey:s,nonceValue:o,signature:i}}){let c=!1,l=new Promise(g=>{let R=o,S=null,N=()=>y(this,null,function*(){try{let{context:M,value:Z}=yield this.getNonceAndContext(s,{commitment:e,minContextSlot:n});return S=M.slot,Z?.nonce}catch{return R}});y(this,null,function*(){if(R=yield N(),!c)for(;;){if(o!==R){g({__type:rt.NONCE_INVALID,slotInWhichNonceDidAdvance:S});return}if(yield Et(2e3),c||(R=yield N(),c))return}})}),{abortConfirmation:d,confirmationPromise:_}=this.getTransactionConfirmationPromise({commitment:e,signature:i}),I=this.getCancellationPromise(t),p;try{let g=yield Promise.race([I,_,l]);if(g.__type===rt.PROCESSED)p=g.response;else{let R;for(;;){let S=yield this.getSignatureStatus(i);if(S==null)break;if(S.context.slot<(g.slotInWhichNonceDidAdvance??n)){yield Et(400);continue}R=S;break}if(R?.value){let S=e||"finalized",{confirmationStatus:N}=R.value;switch(S){case"processed":case"recent":if(N!=="processed"&&N!=="confirmed"&&N!=="finalized")throw new ft(i);break;case"confirmed":case"single":case"singleGossip":if(N!=="confirmed"&&N!=="finalized")throw new ft(i);break;case"finalized":case"max":case"root":if(N!=="finalized")throw new ft(i);break;default:}p={context:R.context,value:{err:R.value.err}}}else throw new ft(i)}}finally{c=!0,d()}return p})}confirmTransactionUsingLegacyTimeoutStrategy(n){return y(this,arguments,function*({commitment:e,signature:t}){let s,o=new Promise(l=>{let d=this._confirmTransactionInitialTimeout||6e4;switch(e){case"processed":case"recent":case"single":case"confirmed":case"singleGossip":{d=this._confirmTransactionInitialTimeout||3e4;break}}s=setTimeout(()=>l({__type:rt.TIMED_OUT,timeoutMs:d}),d)}),{abortConfirmation:i,confirmationPromise:a}=this.getTransactionConfirmationPromise({commitment:e,signature:t}),c;try{let l=yield Promise.race([a,o]);if(l.__type===rt.PROCESSED)c=l.response;else throw new on(t,l.timeoutMs/1e3)}finally{clearTimeout(s),i()}return c})}getClusterNodes(){return y(this,null,function*(){let e=yield this._rpcRequest("getClusterNodes",[]),t=A(e,U(O(Xh)));if("error"in t)throw new T(t.error,"failed to get cluster nodes");return t.result})}getVoteAccounts(e){return y(this,null,function*(){let t=this._buildArgs([],e),n=yield this._rpcRequest("getVoteAccounts",t),s=A(n,Jh);if("error"in s)throw new T(s.error,"failed to get vote accounts");return s.result})}getSlot(e){return y(this,null,function*(){let{commitment:t,config:n}=Q(e),s=this._buildArgs([],t,void 0,n),o=yield this._rpcRequest("getSlot",s),i=A(o,U(f()));if("error"in i)throw new T(i.error,"failed to get slot");return i.result})}getSlotLeader(e){return y(this,null,function*(){let{commitment:t,config:n}=Q(e),s=this._buildArgs([],t,void 0,n),o=yield this._rpcRequest("getSlotLeader",s),i=A(o,U(E()));if("error"in i)throw new T(i.error,"failed to get slot leader");return i.result})}getSlotLeaders(e,t){return y(this,null,function*(){let n=[e,t],s=yield this._rpcRequest("getSlotLeaders",n),o=A(s,U(O(oe)));if("error"in o)throw new T(o.error,"failed to get slot leaders");return o.result})}getSignatureStatus(e,t){return y(this,null,function*(){let{context:n,value:s}=yield this.getSignatureStatuses([e],t);q(s.length===1);let o=s[0];return{context:n,value:o}})}getSignatureStatuses(e,t){return y(this,null,function*(){let n=[e];t&&n.push(t);let s=yield this._rpcRequest("getSignatureStatuses",n),o=A(s,e_);if("error"in o)throw new T(o.error,"failed to get signature status");return o.result})}getTransactionCount(e){return y(this,null,function*(){let{commitment:t,config:n}=Q(e),s=this._buildArgs([],t,void 0,n),o=yield this._rpcRequest("getTransactionCount",s),i=A(o,U(f()));if("error"in i)throw new T(i.error,"failed to get transaction count");return i.result})}getTotalSupply(e){return y(this,null,function*(){return(yield this.getSupply({commitment:e,excludeNonCirculatingAccountsList:!0})).value.total})}getInflationGovernor(e){return y(this,null,function*(){let t=this._buildArgs([],e),n=yield this._rpcRequest("getInflationGovernor",t),s=A(n,Ah);if("error"in s)throw new T(s.error,"failed to get inflation");return s.result})}getInflationReward(e,t,n){return y(this,null,function*(){let{commitment:s,config:o}=Q(n),i=this._buildArgs([e.map(l=>l.toBase58())],s,void 0,F(C({},o),{epoch:t??o?.epoch})),a=yield this._rpcRequest("getInflationReward",i),c=A(a,ch);if("error"in c)throw new T(c.error,"failed to get inflation reward");return c.result})}getInflationRate(){return y(this,null,function*(){let e=yield this._rpcRequest("getInflationRate",[]),t=A(e,Ih);if("error"in t)throw new T(t.error,"failed to get inflation rate");return t.result})}getEpochInfo(e){return y(this,null,function*(){let{commitment:t,config:n}=Q(e),s=this._buildArgs([],t,void 0,n),o=yield this._rpcRequest("getEpochInfo",s),i=A(o,Oh);if("error"in i)throw new T(i.error,"failed to get epoch info");return i.result})}getEpochSchedule(){return y(this,null,function*(){let e=yield this._rpcRequest("getEpochSchedule",[]),t=A(e,kh);if("error"in t)throw new T(t.error,"failed to get epoch schedule");let n=t.result;return new or(n.slotsPerEpoch,n.leaderScheduleSlotOffset,n.warmup,n.firstNormalEpoch,n.firstNormalSlot)})}getLeaderSchedule(){return y(this,null,function*(){let e=yield this._rpcRequest("getLeaderSchedule",[]),t=A(e,Nh);if("error"in t)throw new T(t.error,"failed to get leader schedule");return t.result})}getMinimumBalanceForRentExemption(e,t){return y(this,null,function*(){let n=this._buildArgs([e],t),s=yield this._rpcRequest("getMinimumBalanceForRentExemption",n),o=A(s,t_);return"error"in o?(console.warn("Unable to fetch minimum balance for rent exemption"),0):o.result})}getRecentBlockhashAndContext(e){return y(this,null,function*(){let{context:t,value:{blockhash:n}}=yield this.getLatestBlockhashAndContext(e);return{context:t,value:{blockhash:n,feeCalculator:{get lamportsPerSignature(){throw new Error("The capability to fetch `lamportsPerSignature` using the `getRecentBlockhash` API is no longer offered by the network. Use the `getFeeForMessage` API to obtain the fee for a given message.")},toJSON(){return{}}}}}})}getRecentPerformanceSamples(e){return y(this,null,function*(){let t=yield this._rpcRequest("getRecentPerformanceSamples",e?[e]:[]),n=A(t,__);if("error"in n)throw new T(n.error,"failed to get recent performance samples");return n.result})}getFeeCalculatorForBlockhash(e,t){return y(this,null,function*(){let n=this._buildArgs([e],t),s=yield this._rpcRequest("getFeeCalculatorForBlockhash",n),o=A(s,p_);if("error"in o)throw new T(o.error,"failed to get fee calculator");let{context:i,value:a}=o.result;return{context:i,value:a!==null?a.feeCalculator:null}})}getFeeForMessage(e,t){return y(this,null,function*(){let n=z(e.serialize()).toString("base64"),s=this._buildArgs([n],t),o=yield this._rpcRequest("getFeeForMessage",s),i=A(o,ie(k(f())));if("error"in i)throw new T(i.error,"failed to get fee for message");if(i.result===null)throw new Error("invalid blockhash");return i.result})}getRecentPrioritizationFees(e){return y(this,null,function*(){let t=e?.lockedWritableAccounts?.map(i=>i.toBase58()),n=t?.length?[t]:[],s=yield this._rpcRequest("getRecentPrioritizationFees",n),o=A(s,wh);if("error"in o)throw new T(o.error,"failed to get recent prioritization fees");return o.result})}getRecentBlockhash(e){return y(this,null,function*(){try{return(yield this.getRecentBlockhashAndContext(e)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}})}getLatestBlockhash(e){return y(this,null,function*(){try{return(yield this.getLatestBlockhashAndContext(e)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}})}getLatestBlockhashAndContext(e){return y(this,null,function*(){let{commitment:t,config:n}=Q(e),s=this._buildArgs([],t,void 0,n),o=yield this._rpcRequest("getLatestBlockhash",s),i=A(o,l_);if("error"in i)throw new T(i.error,"failed to get latest blockhash");return i.result})}isBlockhashValid(e,t){return y(this,null,function*(){let{commitment:n,config:s}=Q(t),o=this._buildArgs([e],n,void 0,s),i=yield this._rpcRequest("isBlockhashValid",o),a=A(i,f_);if("error"in a)throw new T(a.error,"failed to determine if the blockhash `"+e+"`is valid");return a.result})}getVersion(){return y(this,null,function*(){let e=yield this._rpcRequest("getVersion",[]),t=A(e,U(yh));if("error"in t)throw new T(t.error,"failed to get version");return t.result})}getGenesisHash(){return y(this,null,function*(){let e=yield this._rpcRequest("getGenesisHash",[]),t=A(e,U(E()));if("error"in t)throw new T(t.error,"failed to get genesis hash");return t.result})}getBlock(e,t){return y(this,null,function*(){let{commitment:n,config:s}=Q(t),o=this._buildArgsAtLeastConfirmed([e],n,void 0,s),i=yield this._rpcRequest("getBlock",o);try{switch(s?.transactionDetails){case"accounts":{let a=A(i,i_);if("error"in a)throw a.error;return a.result}case"none":{let a=A(i,o_);if("error"in a)throw a.error;return a.result}default:{let a=A(i,s_);if("error"in a)throw a.error;let{result:c}=a;return c?F(C({},c),{transactions:c.transactions.map(({transaction:l,meta:d,version:_})=>({meta:d,transaction:F(C({},l),{message:is(_,l.message)}),version:_}))}):null}}}catch(a){throw new T(a,"failed to get confirmed block")}})}getParsedBlock(e,t){return y(this,null,function*(){let{commitment:n,config:s}=Q(t),o=this._buildArgsAtLeastConfirmed([e],n,"jsonParsed",s),i=yield this._rpcRequest("getBlock",o);try{switch(s?.transactionDetails){case"accounts":{let a=A(i,c_);if("error"in a)throw a.error;return a.result}case"none":{let a=A(i,u_);if("error"in a)throw a.error;return a.result}default:{let a=A(i,a_);if("error"in a)throw a.error;return a.result}}}catch(a){throw new T(a,"failed to get block")}})}getBlockProduction(e){return y(this,null,function*(){let t,n;if(typeof e=="string")n=e;else if(e){let a=e,{commitment:c}=a,l=De(a,["commitment"]);n=c,t=l}let s=this._buildArgs([],n,"base64",t),o=yield this._rpcRequest("getBlockProduction",s),i=A(o,mh);if("error"in i)throw new T(i.error,"failed to get block production information");return i.result})}getTransaction(e,t){return y(this,null,function*(){let{commitment:n,config:s}=Q(t),o=this._buildArgsAtLeastConfirmed([e],n,void 0,s),i=yield this._rpcRequest("getTransaction",o),a=A(i,as);if("error"in a)throw new T(a.error,"failed to get transaction");let c=a.result;return c&&F(C({},c),{transaction:F(C({},c.transaction),{message:is(c.version,c.transaction.message)})})})}getParsedTransaction(e,t){return y(this,null,function*(){let{commitment:n,config:s}=Q(t),o=this._buildArgsAtLeastConfirmed([e],n,"jsonParsed",s),i=yield this._rpcRequest("getTransaction",o),a=A(i,Qn);if("error"in a)throw new T(a.error,"failed to get transaction");return a.result})}getParsedTransactions(e,t){return y(this,null,function*(){let{commitment:n,config:s}=Q(t),o=e.map(c=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([c],n,"jsonParsed",s)}));return(yield this._rpcBatchRequest(o)).map(c=>{let l=A(c,Qn);if("error"in l)throw new T(l.error,"failed to get transactions");return l.result})})}getTransactions(e,t){return y(this,null,function*(){let{commitment:n,config:s}=Q(t),o=e.map(c=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([c],n,void 0,s)}));return(yield this._rpcBatchRequest(o)).map(c=>{let l=A(c,as);if("error"in l)throw new T(l.error,"failed to get transactions");let d=l.result;return d&&F(C({},d),{transaction:F(C({},d.transaction),{message:is(d.version,d.transaction.message)})})})})}getConfirmedBlock(e,t){return y(this,null,function*(){let n=this._buildArgsAtLeastConfirmed([e],t),s=yield this._rpcRequest("getBlock",n),o=A(s,d_);if("error"in o)throw new T(o.error,"failed to get confirmed block");let i=o.result;if(!i)throw new Error("Confirmed block "+e+" not found");let a=F(C({},i),{transactions:i.transactions.map(({transaction:c,meta:l})=>{let d=new Ze(c.message);return{meta:l,transaction:F(C({},c),{message:d})}})});return F(C({},a),{transactions:a.transactions.map(({transaction:c,meta:l})=>({meta:l,transaction:Y.populate(c.message,c.signatures)}))})})}getBlocks(e,t,n){return y(this,null,function*(){let s=this._buildArgsAtLeastConfirmed(t!==void 0?[e,t]:[e],n),o=yield this._rpcRequest("getBlocks",s),i=A(o,U(O(f())));if("error"in i)throw new T(i.error,"failed to get blocks");return i.result})}getBlockSignatures(e,t){return y(this,null,function*(){let n=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),s=yield this._rpcRequest("getBlock",n),o=A(s,mi);if("error"in o)throw new T(o.error,"failed to get block");let i=o.result;if(!i)throw new Error("Block "+e+" not found");return i})}getConfirmedBlockSignatures(e,t){return y(this,null,function*(){let n=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),s=yield this._rpcRequest("getBlock",n),o=A(s,mi);if("error"in o)throw new T(o.error,"failed to get confirmed block");let i=o.result;if(!i)throw new Error("Confirmed block "+e+" not found");return i})}getConfirmedTransaction(e,t){return y(this,null,function*(){let n=this._buildArgsAtLeastConfirmed([e],t),s=yield this._rpcRequest("getTransaction",n),o=A(s,as);if("error"in o)throw new T(o.error,"failed to get transaction");let i=o.result;if(!i)return i;let a=new Ze(i.transaction.message),c=i.transaction.signatures;return F(C({},i),{transaction:Y.populate(a,c)})})}getParsedConfirmedTransaction(e,t){return y(this,null,function*(){let n=this._buildArgsAtLeastConfirmed([e],t,"jsonParsed"),s=yield this._rpcRequest("getTransaction",n),o=A(s,Qn);if("error"in o)throw new T(o.error,"failed to get confirmed transaction");return o.result})}getParsedConfirmedTransactions(e,t){return y(this,null,function*(){let n=e.map(i=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([i],t,"jsonParsed")}));return(yield this._rpcBatchRequest(n)).map(i=>{let a=A(i,Qn);if("error"in a)throw new T(a.error,"failed to get confirmed transactions");return a.result})})}getConfirmedSignaturesForAddress(e,t,n){return y(this,null,function*(){let s={},o=yield this.getFirstAvailableBlock();for(;!("until"in s)&&(t--,!(t<=0||t<o));)try{let c=yield this.getConfirmedBlockSignatures(t,"finalized");c.signatures.length>0&&(s.until=c.signatures[c.signatures.length-1].toString())}catch(c){if(c instanceof Error&&c.message.includes("skipped"))continue;throw c}let i=yield this.getSlot("finalized");for(;!("before"in s)&&(n++,!(n>i));)try{let c=yield this.getConfirmedBlockSignatures(n);c.signatures.length>0&&(s.before=c.signatures[c.signatures.length-1].toString())}catch(c){if(c instanceof Error&&c.message.includes("skipped"))continue;throw c}return(yield this.getConfirmedSignaturesForAddress2(e,s)).map(c=>c.signature)})}getConfirmedSignaturesForAddress2(e,t,n){return y(this,null,function*(){let s=this._buildArgsAtLeastConfirmed([e.toBase58()],n,void 0,t),o=yield this._rpcRequest("getConfirmedSignaturesForAddress2",s),i=A(o,Mh);if("error"in i)throw new T(i.error,"failed to get confirmed signatures for address");return i.result})}getSignaturesForAddress(e,t,n){return y(this,null,function*(){let s=this._buildArgsAtLeastConfirmed([e.toBase58()],n,void 0,t),o=yield this._rpcRequest("getSignaturesForAddress",s),i=A(o,Fh);if("error"in i)throw new T(i.error,"failed to get signatures for address");return i.result})}getAddressLookupTable(e,t){return y(this,null,function*(){let{context:n,value:s}=yield this.getAccountInfoAndContext(e,t),o=null;return s!==null&&(o=new an({key:e,state:an.deserialize(s.data)})),{context:n,value:o}})}getNonceAndContext(e,t){return y(this,null,function*(){let{context:n,value:s}=yield this.getAccountInfoAndContext(e,t),o=null;return s!==null&&(o=sr.fromAccountData(s.data)),{context:n,value:o}})}getNonce(e,t){return y(this,null,function*(){return yield this.getNonceAndContext(e,t).then(n=>n.value).catch(n=>{throw new Error("failed to get nonce for account "+e.toBase58()+": "+n)})})}requestAirdrop(e,t){return y(this,null,function*(){let n=yield this._rpcRequest("requestAirdrop",[e.toBase58(),t]),s=A(n,y_);if("error"in s)throw new T(s.error,`airdrop to ${e.toBase58()} failed`);return s.result})}_blockhashWithExpiryBlockHeight(e){return y(this,null,function*(){if(!e){for(;this._pollingBlockhash;)yield Et(100);let n=Date.now()-this._blockhashInfo.lastFetch>=zi;if(this._blockhashInfo.latestBlockhash!==null&&!n)return this._blockhashInfo.latestBlockhash}return yield this._pollNewBlockhash()})}_pollNewBlockhash(){return y(this,null,function*(){this._pollingBlockhash=!0;try{let e=Date.now(),t=this._blockhashInfo.latestBlockhash,n=t?t.blockhash:null;for(let s=0;s<50;s++){let o=yield this.getLatestBlockhash("finalized");if(n!==o.blockhash)return this._blockhashInfo={latestBlockhash:o,lastFetch:Date.now(),transactionSignatures:[],simulatedSignatures:[]},o;yield Et(xi/2)}throw new Error(`Unable to obtain a new blockhash after ${Date.now()-e}ms`)}finally{this._pollingBlockhash=!1}})}getStakeMinimumDelegation(e){return y(this,null,function*(){let{commitment:t,config:n}=Q(e),s=this._buildArgs([],t,"base64",n),o=yield this._rpcRequest("getStakeMinimumDelegation",s),i=A(o,ie(f()));if("error"in i)throw new T(i.error,"failed to get stake minimum delegation");return i.result})}simulateTransaction(e,t,n){return y(this,null,function*(){if("message"in e){let R=e.serialize(),S=P.Buffer.from(R).toString("base64");if(Array.isArray(t)||n!==void 0)throw new Error("Invalid arguments");let N=t||{};N.encoding="base64","commitment"in N||(N.commitment=this.commitment),t&&typeof t=="object"&&"innerInstructions"in t&&(N.innerInstructions=t.innerInstructions);let M=[S,N],Z=yield this._rpcRequest("simulateTransaction",M),v=A(Z,gi);if("error"in v)throw new Error("failed to simulate transaction: "+v.error.message);return v.result}let s;if(e instanceof Y){let g=e;s=new Y,s.feePayer=g.feePayer,s.instructions=e.instructions,s.nonceInfo=g.nonceInfo,s.signatures=g.signatures}else s=Y.populate(e),s._message=s._json=void 0;if(t!==void 0&&!Array.isArray(t))throw new Error("Invalid arguments");let o=t;if(s.nonceInfo&&o)s.sign(...o);else{let g=this._disableBlockhashCaching;for(;;){let R=yield this._blockhashWithExpiryBlockHeight(g);if(s.lastValidBlockHeight=R.lastValidBlockHeight,s.recentBlockhash=R.blockhash,!o)break;if(s.sign(...o),!s.signature)throw new Error("!signature");let S=s.signature.toString("base64");if(!this._blockhashInfo.simulatedSignatures.includes(S)&&!this._blockhashInfo.transactionSignatures.includes(S)){this._blockhashInfo.simulatedSignatures.push(S);break}else g=!0}}let i=s._compile(),a=i.serialize(),l=s._serialize(a).toString("base64"),d={encoding:"base64",commitment:this.commitment};if(n){let g=(Array.isArray(n)?n:i.nonProgramIds()).map(R=>R.toBase58());d.accounts={encoding:"base64",addresses:g}}o&&(d.sigVerify=!0),t&&typeof t=="object"&&"innerInstructions"in t&&(d.innerInstructions=t.innerInstructions);let _=[l,d],I=yield this._rpcRequest("simulateTransaction",_),p=A(I,gi);if("error"in p){let g;if("data"in p.error&&(g=p.error.data.logs,g&&Array.isArray(g))){let R=`
    `,S=R+g.join(R);console.error(p.error.message,S)}throw new It({action:"simulate",signature:"",transactionMessage:p.error.message,logs:g})}return p.result})}sendTransaction(e,t,n){return y(this,null,function*(){if("version"in e){if(t&&Array.isArray(t))throw new Error("Invalid arguments");let i=e.serialize();return yield this.sendRawTransaction(i,t)}if(t===void 0||!Array.isArray(t))throw new Error("Invalid arguments");let s=t;if(e.nonceInfo)e.sign(...s);else{let i=this._disableBlockhashCaching;for(;;){let a=yield this._blockhashWithExpiryBlockHeight(i);if(e.lastValidBlockHeight=a.lastValidBlockHeight,e.recentBlockhash=a.blockhash,e.sign(...s),!e.signature)throw new Error("!signature");let c=e.signature.toString("base64");if(this._blockhashInfo.transactionSignatures.includes(c))i=!0;else{this._blockhashInfo.transactionSignatures.push(c);break}}}let o=e.serialize();return yield this.sendRawTransaction(o,n)})}sendRawTransaction(e,t){return y(this,null,function*(){let n=z(e).toString("base64");return yield this.sendEncodedTransaction(n,t)})}sendEncodedTransaction(e,t){return y(this,null,function*(){let n={encoding:"base64"},s=t&&t.skipPreflight,o=s===!0?"processed":t&&t.preflightCommitment||this.commitment;t&&t.maxRetries!=null&&(n.maxRetries=t.maxRetries),t&&t.minContextSlot!=null&&(n.minContextSlot=t.minContextSlot),s&&(n.skipPreflight=s),o&&(n.preflightCommitment=o);let i=[e,n],a=yield this._rpcRequest("sendTransaction",i),c=A(a,g_);if("error"in c){let l;throw"data"in c.error&&(l=c.error.data.logs),new It({action:s?"send":"simulate",signature:"",transactionMessage:c.error.message,logs:l})}return c.result})}_wsOnOpen(){this._rpcWebSocketConnected=!0,this._rpcWebSocketHeartbeat=setInterval(()=>{y(this,null,function*(){try{yield this._rpcWebSocket.notify("ping")}catch{}})},5e3),this._updateSubscriptions()}_wsOnError(e){this._rpcWebSocketConnected=!1,console.error("ws error:",e.message)}_wsOnClose(e){if(this._rpcWebSocketConnected=!1,this._rpcWebSocketGeneration=(this._rpcWebSocketGeneration+1)%Number.MAX_SAFE_INTEGER,this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null),this._rpcWebSocketHeartbeat&&(clearInterval(this._rpcWebSocketHeartbeat),this._rpcWebSocketHeartbeat=null),e===1e3){this._updateSubscriptions();return}this._subscriptionCallbacksByServerSubscriptionId={},Object.entries(this._subscriptionsByHash).forEach(([t,n])=>{this._setSubscription(t,F(C({},n),{state:"pending"}))})}_setSubscription(e,t){let n=this._subscriptionsByHash[e]?.state;if(this._subscriptionsByHash[e]=t,n!==t.state){let s=this._subscriptionStateChangeCallbacksByHash[e];s&&s.forEach(o=>{try{o(t.state)}catch{}})}}_onSubscriptionStateChange(e,t){let n=this._subscriptionHashByClientSubscriptionId[e];if(n==null)return()=>{};let s=this._subscriptionStateChangeCallbacksByHash[n]||=new Set;return s.add(t),()=>{s.delete(t),s.size===0&&delete this._subscriptionStateChangeCallbacksByHash[n]}}_updateSubscriptions(){return y(this,null,function*(){if(Object.keys(this._subscriptionsByHash).length===0){this._rpcWebSocketConnected&&(this._rpcWebSocketConnected=!1,this._rpcWebSocketIdleTimeout=setTimeout(()=>{this._rpcWebSocketIdleTimeout=null;try{this._rpcWebSocket.close()}catch(n){n instanceof Error&&console.log(`Error when closing socket connection: ${n.message}`)}},500));return}if(this._rpcWebSocketIdleTimeout!==null&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketConnected=!0),!this._rpcWebSocketConnected){this._rpcWebSocket.connect();return}let e=this._rpcWebSocketGeneration,t=()=>e===this._rpcWebSocketGeneration;yield Promise.all(Object.keys(this._subscriptionsByHash).map(n=>y(this,null,function*(){let s=this._subscriptionsByHash[n];if(s!==void 0)switch(s.state){case"pending":case"unsubscribed":if(s.callbacks.size===0){delete this._subscriptionsByHash[n],s.state==="unsubscribed"&&delete this._subscriptionCallbacksByServerSubscriptionId[s.serverSubscriptionId],yield this._updateSubscriptions();return}yield y(this,null,function*(){let{args:o,method:i}=s;try{this._setSubscription(n,F(C({},s),{state:"subscribing"}));let a=yield this._rpcWebSocket.call(i,o);this._setSubscription(n,F(C({},s),{serverSubscriptionId:a,state:"subscribed"})),this._subscriptionCallbacksByServerSubscriptionId[a]=s.callbacks,yield this._updateSubscriptions()}catch(a){if(console.error(`Received ${a instanceof Error?"":"JSON-RPC "}error calling \`${i}\``,{args:o,error:a}),!t())return;this._setSubscription(n,F(C({},s),{state:"pending"})),yield this._updateSubscriptions()}});break;case"subscribed":s.callbacks.size===0&&(yield y(this,null,function*(){let{serverSubscriptionId:o,unsubscribeMethod:i}=s;if(this._subscriptionsAutoDisposedByRpc.has(o))this._subscriptionsAutoDisposedByRpc.delete(o);else{this._setSubscription(n,F(C({},s),{state:"unsubscribing"})),this._setSubscription(n,F(C({},s),{state:"unsubscribing"}));try{yield this._rpcWebSocket.call(i,[o])}catch(a){if(a instanceof Error&&console.error(`${i} error:`,a.message),!t())return;this._setSubscription(n,F(C({},s),{state:"subscribed"})),yield this._updateSubscriptions();return}}this._setSubscription(n,F(C({},s),{state:"unsubscribed"})),yield this._updateSubscriptions()}));break}})))})}_handleServerNotification(e,t){let n=this._subscriptionCallbacksByServerSubscriptionId[e];n!==void 0&&n.forEach(s=>{try{s(...t)}catch(o){console.error(o)}})}_wsOnAccountNotification(e){let{result:t,subscription:n}=A(e,Kh);this._handleServerNotification(n,[t.value,t.context])}_makeSubscription(e,t){let n=this._nextClientSubscriptionId++,s=_i([e.method,t]),o=this._subscriptionsByHash[s];return o===void 0?this._subscriptionsByHash[s]=F(C({},e),{args:t,callbacks:new Set([e.callback]),state:"pending"}):o.callbacks.add(e.callback),this._subscriptionHashByClientSubscriptionId[n]=s,this._subscriptionDisposeFunctionsByClientSubscriptionId[n]=()=>y(this,null,function*(){delete this._subscriptionDisposeFunctionsByClientSubscriptionId[n],delete this._subscriptionHashByClientSubscriptionId[n];let i=this._subscriptionsByHash[s];q(i!==void 0,`Could not find a \`Subscription\` when tearing down client subscription #${n}`),i.callbacks.delete(e.callback),yield this._updateSubscriptions()}),this._updateSubscriptions(),n}onAccountChange(e,t,n){let{commitment:s,config:o}=Q(n),i=this._buildArgs([e.toBase58()],s||this._commitment||"finalized","base64",o);return this._makeSubscription({callback:t,method:"accountSubscribe",unsubscribeMethod:"accountUnsubscribe"},i)}removeAccountChangeListener(e){return y(this,null,function*(){yield this._unsubscribeClientSubscription(e,"account change")})}_wsOnProgramAccountNotification(e){let{result:t,subscription:n}=A(e,$h);this._handleServerNotification(n,[{accountId:t.value.pubkey,accountInfo:t.value.account},t.context])}onProgramAccountChange(e,t,n,s){let{commitment:o,config:i}=Q(n),a=this._buildArgs([e.toBase58()],o||this._commitment||"finalized","base64",i||(s?{filters:yi(s)}:void 0));return this._makeSubscription({callback:t,method:"programSubscribe",unsubscribeMethod:"programUnsubscribe"},a)}removeProgramAccountChangeListener(e){return y(this,null,function*(){yield this._unsubscribeClientSubscription(e,"program account change")})}onLogs(e,t,n){let s=this._buildArgs([typeof e=="object"?{mentions:[e.toString()]}:e],n||this._commitment||"finalized");return this._makeSubscription({callback:t,method:"logsSubscribe",unsubscribeMethod:"logsUnsubscribe"},s)}removeOnLogsListener(e){return y(this,null,function*(){yield this._unsubscribeClientSubscription(e,"logs")})}_wsOnLogsNotification(e){let{result:t,subscription:n}=A(e,m_);this._handleServerNotification(n,[t.value,t.context])}_wsOnSlotNotification(e){let{result:t,subscription:n}=A(e,Gh);this._handleServerNotification(n,[t])}onSlotChange(e){return this._makeSubscription({callback:e,method:"slotSubscribe",unsubscribeMethod:"slotUnsubscribe"},[])}removeSlotChangeListener(e){return y(this,null,function*(){yield this._unsubscribeClientSubscription(e,"slot change")})}_wsOnSlotUpdatesNotification(e){let{result:t,subscription:n}=A(e,Hh);this._handleServerNotification(n,[t])}onSlotUpdate(e){return this._makeSubscription({callback:e,method:"slotsUpdatesSubscribe",unsubscribeMethod:"slotsUpdatesUnsubscribe"},[])}removeSlotUpdateListener(e){return y(this,null,function*(){yield this._unsubscribeClientSubscription(e,"slot update")})}_unsubscribeClientSubscription(e,t){return y(this,null,function*(){let n=this._subscriptionDisposeFunctionsByClientSubscriptionId[e];n?yield n():console.warn(`Ignored unsubscribe request because an active subscription with id \`${e}\` for '${t}' events could not be found.`)})}_buildArgs(e,t,n,s){let o=t||this._commitment;if(o||n||s){let i={};n&&(i.encoding=n),o&&(i.commitment=o),s&&(i=Object.assign(i,s)),e.push(i)}return e}_buildArgsAtLeastConfirmed(e,t,n,s){let o=t||this._commitment;if(o&&!["confirmed","finalized"].includes(o))throw new Error("Using Connection with default commitment: `"+this._commitment+"`, but method requires at least `confirmed`");return this._buildArgs(e,t,n,s)}_wsOnSignatureNotification(e){let{result:t,subscription:n}=A(e,jh);t.value!=="receivedSignature"&&this._subscriptionsAutoDisposedByRpc.add(n),this._handleServerNotification(n,t.value==="receivedSignature"?[{type:"received"},t.context]:[{type:"status",result:t.value},t.context])}onSignature(e,t,n){let s=this._buildArgs([e],n||this._commitment||"finalized"),o=this._makeSubscription({callback:(i,a)=>{if(i.type==="status"){t(i.result,a);try{this.removeSignatureListener(o)}catch{}}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},s);return o}onSignatureWithOptions(e,t,n){let c=F(C({},n),{commitment:n&&n.commitment||this._commitment||"finalized"}),{commitment:s}=c,o=De(c,["commitment"]),i=this._buildArgs([e],s,void 0,o),a=this._makeSubscription({callback:(l,d)=>{t(l,d);try{this.removeSignatureListener(a)}catch{}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},i);return a}removeSignatureListener(e){return y(this,null,function*(){yield this._unsubscribeClientSubscription(e,"signature result")})}_wsOnRootNotification(e){let{result:t,subscription:n}=A(e,Yh);this._handleServerNotification(n,[t])}onRootChange(e){return this._makeSubscription({callback:e,method:"rootSubscribe",unsubscribeMethod:"rootUnsubscribe"},[])}removeRootChangeListener(e){return y(this,null,function*(){yield this._unsubscribeClientSubscription(e,"root change")})}},ar=class r{constructor(e){this._keypair=void 0,this._keypair=e??di()}static generate(){return new r(di())}static fromSecretKey(e,t){if(e.byteLength!==64)throw new Error("bad secret key size");let n=e.slice(32,64);if(!t||!t.skipValidation){let s=e.slice(0,32),o=nr(s);for(let i=0;i<32;i++)if(n[i]!==o[i])throw new Error("provided secretKey is invalid")}return new r({publicKey:n,secretKey:e})}static fromSeed(e){let t=nr(e),n=new Uint8Array(64);return n.set(e),n.set(t,32),new r({publicKey:t,secretKey:n})}get publicKey(){return new w(this._keypair.publicKey)}get secretKey(){return new Uint8Array(this._keypair.secretKey)}},st=Object.freeze({CreateLookupTable:{index:0,layout:u.struct([u.u32("instruction"),Ut("recentSlot"),u.u8("bumpSeed")])},FreezeLookupTable:{index:1,layout:u.struct([u.u32("instruction")])},ExtendLookupTable:{index:2,layout:u.struct([u.u32("instruction"),Ut(),u.seq(K(),u.offset(u.u32(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:u.struct([u.u32("instruction")])},CloseLookupTable:{index:4,layout:u.struct([u.u32("instruction")])}}),ws=class{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);let n=u.u32("instruction").decode(e.data),s;for(let[o,i]of Object.entries(st))if(i.index==n){s=o;break}if(!s)throw new Error("Invalid Instruction. Should be a LookupTable Instruction");return s}static decodeCreateLookupTable(e){this.checkProgramId(e.programId),this.checkKeysLength(e.keys,4);let{recentSlot:t}=j(st.CreateLookupTable,e.data);return{authority:e.keys[1].pubkey,payer:e.keys[2].pubkey,recentSlot:Number(t)}}static decodeExtendLookupTable(e){if(this.checkProgramId(e.programId),e.keys.length<2)throw new Error(`invalid instruction; found ${e.keys.length} keys, expected at least 2`);let{addresses:t}=j(st.ExtendLookupTable,e.data);return{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey,payer:e.keys.length>2?e.keys[2].pubkey:void 0,addresses:t.map(n=>new w(n))}}static decodeCloseLookupTable(e){return this.checkProgramId(e.programId),this.checkKeysLength(e.keys,3),{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey,recipient:e.keys[2].pubkey}}static decodeFreezeLookupTable(e){return this.checkProgramId(e.programId),this.checkKeysLength(e.keys,2),{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey}}static decodeDeactivateLookupTable(e){return this.checkProgramId(e.programId),this.checkKeysLength(e.keys,2),{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey}}static checkProgramId(e){if(!e.equals(un.programId))throw new Error("invalid instruction; programId is not AddressLookupTable Program")}static checkKeysLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}},un=class{constructor(){}static createLookupTable(e){let[t,n]=w.findProgramAddressSync([e.authority.toBuffer(),$r().encode(e.recentSlot)],this.programId),s=st.CreateLookupTable,o=$(s,{recentSlot:BigInt(e.recentSlot),bumpSeed:n}),i=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:_e.programId,isSigner:!1,isWritable:!1}];return[new X({programId:this.programId,keys:i,data:o}),t]}static freezeLookupTable(e){let t=st.FreezeLookupTable,n=$(t),s=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new X({programId:this.programId,keys:s,data:n})}static extendLookupTable(e){let t=st.ExtendLookupTable,n=$(t,{addresses:e.addresses.map(o=>o.toBytes())}),s=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return e.payer&&s.push({pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:_e.programId,isSigner:!1,isWritable:!1}),new X({programId:this.programId,keys:s,data:n})}static deactivateLookupTable(e){let t=st.DeactivateLookupTable,n=$(t),s=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new X({programId:this.programId,keys:s,data:n})}static closeLookupTable(e){let t=st.CloseLookupTable,n=$(t),s=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.recipient,isSigner:!1,isWritable:!0}];return new X({programId:this.programId,keys:s,data:n})}};un.programId=new w("AddressLookupTab1e1111111111111111111111111");Os=class{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);let n=u.u8("instruction").decode(e.data),s;for(let[o,i]of Object.entries(Ye))if(i.index==n){s=o;break}if(!s)throw new Error("Instruction type incorrect; not a ComputeBudgetInstruction");return s}static decodeRequestUnits(e){this.checkProgramId(e.programId);let{units:t,additionalFee:n}=j(Ye.RequestUnits,e.data);return{units:t,additionalFee:n}}static decodeRequestHeapFrame(e){this.checkProgramId(e.programId);let{bytes:t}=j(Ye.RequestHeapFrame,e.data);return{bytes:t}}static decodeSetComputeUnitLimit(e){this.checkProgramId(e.programId);let{units:t}=j(Ye.SetComputeUnitLimit,e.data);return{units:t}}static decodeSetComputeUnitPrice(e){this.checkProgramId(e.programId);let{microLamports:t}=j(Ye.SetComputeUnitPrice,e.data);return{microLamports:t}}static checkProgramId(e){if(!e.equals(dn.programId))throw new Error("invalid instruction; programId is not ComputeBudgetProgram")}},Ye=Object.freeze({RequestUnits:{index:0,layout:u.struct([u.u8("instruction"),u.u32("units"),u.u32("additionalFee")])},RequestHeapFrame:{index:1,layout:u.struct([u.u8("instruction"),u.u32("bytes")])},SetComputeUnitLimit:{index:2,layout:u.struct([u.u8("instruction"),u.u32("units")])},SetComputeUnitPrice:{index:3,layout:u.struct([u.u8("instruction"),Ut("microLamports")])}}),dn=class{constructor(){}static requestUnits(e){let t=Ye.RequestUnits,n=$(t,e);return new X({keys:[],programId:this.programId,data:n})}static requestHeapFrame(e){let t=Ye.RequestHeapFrame,n=$(t,e);return new X({keys:[],programId:this.programId,data:n})}static setComputeUnitLimit(e){let t=Ye.SetComputeUnitLimit,n=$(t,e);return new X({keys:[],programId:this.programId,data:n})}static setComputeUnitPrice(e){let t=Ye.SetComputeUnitPrice,n=$(t,{microLamports:BigInt(e.microLamports)});return new X({keys:[],programId:this.programId,data:n})}};dn.programId=new w("ComputeBudget111111111111111111111111111111");Si=64,Ei=32,bi=64,Ai=u.struct([u.u8("numSignatures"),u.u8("padding"),u.u16("signatureOffset"),u.u16("signatureInstructionIndex"),u.u16("publicKeyOffset"),u.u16("publicKeyInstructionIndex"),u.u16("messageDataOffset"),u.u16("messageDataSize"),u.u16("messageInstructionIndex")]),cr=class r{constructor(){}static createInstructionWithPublicKey(e){let{publicKey:t,message:n,signature:s,instructionIndex:o}=e;q(t.length===Ei,`Public Key must be ${Ei} bytes but received ${t.length} bytes`),q(s.length===bi,`Signature must be ${bi} bytes but received ${s.length} bytes`);let i=Ai.span,a=i+t.length,c=a+s.length,l=1,d=P.Buffer.alloc(c+n.length),_=o??65535;return Ai.encode({numSignatures:l,padding:0,signatureOffset:a,signatureInstructionIndex:_,publicKeyOffset:i,publicKeyInstructionIndex:_,messageDataOffset:c,messageDataSize:n.length,messageInstructionIndex:_},d),d.fill(t,i),d.fill(s,a),d.fill(n,c),new X({keys:[],programId:r.programId,data:d})}static createInstructionWithPrivateKey(e){let{privateKey:t,message:n,instructionIndex:s}=e;q(t.length===Si,`Private key must be ${Si} bytes but received ${t.length} bytes`);try{let o=ar.fromSecretKey(t),i=o.publicKey.toBytes(),a=vs(n,o.secretKey);return this.createInstructionWithPublicKey({publicKey:i,message:n,signature:a,instructionIndex:s})}catch(o){throw new Error(`Error creating instruction; ${o}`)}}};cr.programId=new w("Ed25519SigVerify111111111111111111111111111");E_=(r,e)=>{let t=yn.sign(r,e);return[t.toCompactRawBytes(),t.recovery]};yn.utils.isValidPrivateKey;b_=yn.getPublicKey,Ii=32,cs=20,wi=64,A_=11,us=u.struct([u.u8("numSignatures"),u.u16("signatureOffset"),u.u8("signatureInstructionIndex"),u.u16("ethAddressOffset"),u.u8("ethAddressInstructionIndex"),u.u16("messageDataOffset"),u.u16("messageDataSize"),u.u8("messageInstructionIndex"),u.blob(20,"ethAddress"),u.blob(64,"signature"),u.u8("recoveryId")]),ur=class r{constructor(){}static publicKeyToEthAddress(e){q(e.length===wi,`Public key must be ${wi} bytes but received ${e.length} bytes`);try{return P.Buffer.from(mr(z(e))).slice(-cs)}catch(t){throw new Error(`Error constructing Ethereum address: ${t}`)}}static createInstructionWithPublicKey(e){let{publicKey:t,message:n,signature:s,recoveryId:o,instructionIndex:i}=e;return r.createInstructionWithEthAddress({ethAddress:r.publicKeyToEthAddress(t),message:n,signature:s,recoveryId:o,instructionIndex:i})}static createInstructionWithEthAddress(e){let{ethAddress:t,message:n,signature:s,recoveryId:o,instructionIndex:i=0}=e,a;typeof t=="string"?t.startsWith("0x")?a=P.Buffer.from(t.substr(2),"hex"):a=P.Buffer.from(t,"hex"):a=t,q(a.length===cs,`Address must be ${cs} bytes but received ${a.length} bytes`);let c=1+A_,l=c,d=c+a.length,_=d+s.length+1,I=1,p=P.Buffer.alloc(us.span+n.length);return us.encode({numSignatures:I,signatureOffset:d,signatureInstructionIndex:i,ethAddressOffset:l,ethAddressInstructionIndex:i,messageDataOffset:_,messageDataSize:n.length,messageInstructionIndex:i,signature:z(s),ethAddress:z(a),recoveryId:o},p),p.fill(z(n),us.span),new X({keys:[],programId:r.programId,data:p})}static createInstructionWithPrivateKey(e){let{privateKey:t,message:n,instructionIndex:s}=e;q(t.length===Ii,`Private key must be ${Ii} bytes but received ${t.length} bytes`);try{let o=z(t),i=b_(o,!1).slice(1),a=P.Buffer.from(mr(z(n))),[c,l]=E_(a,o);return this.createInstructionWithPublicKey({publicKey:i,message:n,signature:c,recoveryId:l,instructionIndex:s})}catch(o){throw new Error(`Error creating instruction; ${o}`)}}};ur.programId=new w("KeccakSecp256k11111111111111111111111111111");Yi=new w("StakeConfig11111111111111111111111111111111"),dr=class{constructor(e,t){this.staker=void 0,this.withdrawer=void 0,this.staker=e,this.withdrawer=t}},wt=class{constructor(e,t,n){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=e,this.epoch=t,this.custodian=n}};ji=wt;wt.default=new ji(0,0,w.default);ks=class{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);let n=u.u32("instruction").decode(e.data),s;for(let[o,i]of Object.entries(de))if(i.index==n){s=o;break}if(!s)throw new Error("Instruction type incorrect; not a StakeInstruction");return s}static decodeInitialize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);let{authorized:t,lockup:n}=j(de.Initialize,e.data);return{stakePubkey:e.keys[0].pubkey,authorized:new dr(new w(t.staker),new w(t.withdrawer)),lockup:new wt(n.unixTimestamp,n.epoch,new w(n.custodian))}}static decodeDelegate(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,6),j(de.Delegate,e.data),{stakePubkey:e.keys[0].pubkey,votePubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[5].pubkey}}static decodeAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);let{newAuthorized:t,stakeAuthorizationType:n}=j(de.Authorize,e.data),s={stakePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey,newAuthorizedPubkey:new w(t),stakeAuthorizationType:{index:n}};return e.keys.length>3&&(s.custodianPubkey=e.keys[3].pubkey),s}static decodeAuthorizeWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);let{newAuthorized:t,stakeAuthorizationType:n,authoritySeed:s,authorityOwner:o}=j(de.AuthorizeWithSeed,e.data),i={stakePubkey:e.keys[0].pubkey,authorityBase:e.keys[1].pubkey,authoritySeed:s,authorityOwner:new w(o),newAuthorizedPubkey:new w(t),stakeAuthorizationType:{index:n}};return e.keys.length>3&&(i.custodianPubkey=e.keys[3].pubkey),i}static decodeSplit(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);let{lamports:t}=j(de.Split,e.data);return{stakePubkey:e.keys[0].pubkey,splitStakePubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[2].pubkey,lamports:t}}static decodeMerge(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),j(de.Merge,e.data),{stakePubkey:e.keys[0].pubkey,sourceStakePubKey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey}}static decodeWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,5);let{lamports:t}=j(de.Withdraw,e.data),n={stakePubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey,lamports:t};return e.keys.length>5&&(n.custodianPubkey=e.keys[5].pubkey),n}static decodeDeactivate(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),j(de.Deactivate,e.data),{stakePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey}}static checkProgramId(e){if(!e.equals(zt.programId))throw new Error("invalid instruction; programId is not StakeProgram")}static checkKeyLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}},de=Object.freeze({Initialize:{index:0,layout:u.struct([u.u32("instruction"),xf(),Pf()])},Authorize:{index:1,layout:u.struct([u.u32("instruction"),K("newAuthorized"),u.u32("stakeAuthorizationType")])},Delegate:{index:2,layout:u.struct([u.u32("instruction")])},Split:{index:3,layout:u.struct([u.u32("instruction"),u.ns64("lamports")])},Withdraw:{index:4,layout:u.struct([u.u32("instruction"),u.ns64("lamports")])},Deactivate:{index:5,layout:u.struct([u.u32("instruction")])},Merge:{index:7,layout:u.struct([u.u32("instruction")])},AuthorizeWithSeed:{index:8,layout:u.struct([u.u32("instruction"),K("newAuthorized"),u.u32("stakeAuthorizationType"),bt("authoritySeed"),K("authorityOwner")])}}),I_=Object.freeze({Staker:{index:0},Withdrawer:{index:1}}),zt=class{constructor(){}static initialize(e){let{stakePubkey:t,authorized:n,lockup:s}=e,o=s||wt.default,i=de.Initialize,a=$(i,{authorized:{staker:z(n.staker.toBuffer()),withdrawer:z(n.withdrawer.toBuffer())},lockup:{unixTimestamp:o.unixTimestamp,epoch:o.epoch,custodian:z(o.custodian.toBuffer())}}),c={keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Dt,isSigner:!1,isWritable:!1}],programId:this.programId,data:a};return new X(c)}static createAccountWithSeed(e){let t=new Y;t.add(_e.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:this.space,programId:this.programId}));let{stakePubkey:n,authorized:s,lockup:o}=e;return t.add(this.initialize({stakePubkey:n,authorized:s,lockup:o}))}static createAccount(e){let t=new Y;t.add(_e.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,lamports:e.lamports,space:this.space,programId:this.programId}));let{stakePubkey:n,authorized:s,lockup:o}=e;return t.add(this.initialize({stakePubkey:n,authorized:s,lockup:o}))}static delegate(e){let{stakePubkey:t,authorizedPubkey:n,votePubkey:s}=e,o=de.Delegate,i=$(o);return new Y().add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:He,isSigner:!1,isWritable:!1},{pubkey:tr,isSigner:!1,isWritable:!1},{pubkey:Yi,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:i})}static authorize(e){let{stakePubkey:t,authorizedPubkey:n,newAuthorizedPubkey:s,stakeAuthorizationType:o,custodianPubkey:i}=e,a=de.Authorize,c=$(a,{newAuthorized:z(s.toBuffer()),stakeAuthorizationType:o.index}),l=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:He,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1}];return i&&l.push({pubkey:i,isSigner:!0,isWritable:!1}),new Y().add({keys:l,programId:this.programId,data:c})}static authorizeWithSeed(e){let{stakePubkey:t,authorityBase:n,authoritySeed:s,authorityOwner:o,newAuthorizedPubkey:i,stakeAuthorizationType:a,custodianPubkey:c}=e,l=de.AuthorizeWithSeed,d=$(l,{newAuthorized:z(i.toBuffer()),stakeAuthorizationType:a.index,authoritySeed:s,authorityOwner:z(o.toBuffer())}),_=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1},{pubkey:He,isSigner:!1,isWritable:!1}];return c&&_.push({pubkey:c,isSigner:!0,isWritable:!1}),new Y().add({keys:_,programId:this.programId,data:d})}static splitInstruction(e){let{stakePubkey:t,authorizedPubkey:n,splitStakePubkey:s,lamports:o}=e,i=de.Split,a=$(i,{lamports:o});return new X({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:a})}static split(e,t){let n=new Y;return n.add(_e.createAccount({fromPubkey:e.authorizedPubkey,newAccountPubkey:e.splitStakePubkey,lamports:t,space:this.space,programId:this.programId})),n.add(this.splitInstruction(e))}static splitWithSeed(e,t){let{stakePubkey:n,authorizedPubkey:s,splitStakePubkey:o,basePubkey:i,seed:a,lamports:c}=e,l=new Y;return l.add(_e.allocate({accountPubkey:o,basePubkey:i,seed:a,space:this.space,programId:this.programId})),t&&t>0&&l.add(_e.transfer({fromPubkey:e.authorizedPubkey,toPubkey:o,lamports:t})),l.add(this.splitInstruction({stakePubkey:n,authorizedPubkey:s,splitStakePubkey:o,lamports:c}))}static merge(e){let{stakePubkey:t,sourceStakePubKey:n,authorizedPubkey:s}=e,o=de.Merge,i=$(o);return new Y().add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:He,isSigner:!1,isWritable:!1},{pubkey:tr,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!0,isWritable:!1}],programId:this.programId,data:i})}static withdraw(e){let{stakePubkey:t,authorizedPubkey:n,toPubkey:s,lamports:o,custodianPubkey:i}=e,a=de.Withdraw,c=$(a,{lamports:o}),l=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:He,isSigner:!1,isWritable:!1},{pubkey:tr,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}];return i&&l.push({pubkey:i,isSigner:!0,isWritable:!1}),new Y().add({keys:l,programId:this.programId,data:c})}static deactivate(e){let{stakePubkey:t,authorizedPubkey:n}=e,s=de.Deactivate,o=$(s);return new Y().add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:He,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:o})}};zt.programId=new w("Stake11111111111111111111111111111111111111");zt.space=200;lr=class{constructor(e,t,n,s){this.nodePubkey=void 0,this.authorizedVoter=void 0,this.authorizedWithdrawer=void 0,this.commission=void 0,this.nodePubkey=e,this.authorizedVoter=t,this.authorizedWithdrawer=n,this.commission=s}},Ns=class{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);let n=u.u32("instruction").decode(e.data),s;for(let[o,i]of Object.entries(Xe))if(i.index==n){s=o;break}if(!s)throw new Error("Instruction type incorrect; not a VoteInstruction");return s}static decodeInitializeAccount(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,4);let{voteInit:t}=j(Xe.InitializeAccount,e.data);return{votePubkey:e.keys[0].pubkey,nodePubkey:e.keys[3].pubkey,voteInit:new lr(new w(t.nodePubkey),new w(t.authorizedVoter),new w(t.authorizedWithdrawer),t.commission)}}static decodeAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);let{newAuthorized:t,voteAuthorizationType:n}=j(Xe.Authorize,e.data);return{votePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey,newAuthorizedPubkey:new w(t),voteAuthorizationType:{index:n}}}static decodeAuthorizeWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);let{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:t,currentAuthorityDerivedKeySeed:n,newAuthorized:s,voteAuthorizationType:o}}=j(Xe.AuthorizeWithSeed,e.data);return{currentAuthorityDerivedKeyBasePubkey:e.keys[2].pubkey,currentAuthorityDerivedKeyOwnerPubkey:new w(t),currentAuthorityDerivedKeySeed:n,newAuthorizedPubkey:new w(s),voteAuthorizationType:{index:o},votePubkey:e.keys[0].pubkey}}static decodeWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);let{lamports:t}=j(Xe.Withdraw,e.data);return{votePubkey:e.keys[0].pubkey,authorizedWithdrawerPubkey:e.keys[2].pubkey,lamports:t,toPubkey:e.keys[1].pubkey}}static checkProgramId(e){if(!e.equals(Mt.programId))throw new Error("invalid instruction; programId is not VoteProgram")}static checkKeyLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}},Xe=Object.freeze({InitializeAccount:{index:0,layout:u.struct([u.u32("instruction"),Df()])},Authorize:{index:1,layout:u.struct([u.u32("instruction"),K("newAuthorized"),u.u32("voteAuthorizationType")])},Withdraw:{index:3,layout:u.struct([u.u32("instruction"),u.ns64("lamports")])},UpdateValidatorIdentity:{index:4,layout:u.struct([u.u32("instruction")])},AuthorizeWithSeed:{index:10,layout:u.struct([u.u32("instruction"),Uf()])}}),w_=Object.freeze({Voter:{index:0},Withdrawer:{index:1}}),Mt=class r{constructor(){}static initializeAccount(e){let{votePubkey:t,nodePubkey:n,voteInit:s}=e,o=Xe.InitializeAccount,i=$(o,{voteInit:{nodePubkey:z(s.nodePubkey.toBuffer()),authorizedVoter:z(s.authorizedVoter.toBuffer()),authorizedWithdrawer:z(s.authorizedWithdrawer.toBuffer()),commission:s.commission}}),a={keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Dt,isSigner:!1,isWritable:!1},{pubkey:He,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:i};return new X(a)}static createAccount(e){let t=new Y;return t.add(_e.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.votePubkey,lamports:e.lamports,space:this.space,programId:this.programId})),t.add(this.initializeAccount({votePubkey:e.votePubkey,nodePubkey:e.voteInit.nodePubkey,voteInit:e.voteInit}))}static authorize(e){let{votePubkey:t,authorizedPubkey:n,newAuthorizedPubkey:s,voteAuthorizationType:o}=e,i=Xe.Authorize,a=$(i,{newAuthorized:z(s.toBuffer()),voteAuthorizationType:o.index}),c=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:He,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}];return new Y().add({keys:c,programId:this.programId,data:a})}static authorizeWithSeed(e){let{currentAuthorityDerivedKeyBasePubkey:t,currentAuthorityDerivedKeyOwnerPubkey:n,currentAuthorityDerivedKeySeed:s,newAuthorizedPubkey:o,voteAuthorizationType:i,votePubkey:a}=e,c=Xe.AuthorizeWithSeed,l=$(c,{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:z(n.toBuffer()),currentAuthorityDerivedKeySeed:s,newAuthorized:z(o.toBuffer()),voteAuthorizationType:i.index}}),d=[{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:He,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!0,isWritable:!1}];return new Y().add({keys:d,programId:this.programId,data:l})}static withdraw(e){let{votePubkey:t,authorizedWithdrawerPubkey:n,lamports:s,toPubkey:o}=e,i=Xe.Withdraw,a=$(i,{lamports:s}),c=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1}];return new Y().add({keys:c,programId:this.programId,data:a})}static safeWithdraw(e,t,n){if(e.lamports>t-n)throw new Error("Withdraw will leave vote account with insufficient funds.");return r.withdraw(e)}static updateValidatorIdentity(e){let{votePubkey:t,authorizedWithdrawerPubkey:n,nodePubkey:s}=e,o=Xe.UpdateValidatorIdentity,i=$(o),a=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}];return new Y().add({keys:a,programId:this.programId,data:i})}};Mt.programId=new w("Vote111111111111111111111111111111111111111");Mt.space=3762;Xi=new w("Va1idator1nfo111111111111111111111111111111"),O_=m({name:E(),website:B(E()),details:B(E()),iconUrl:B(E()),keybaseUsername:B(E())}),Ts=class r{constructor(e,t){this.key=void 0,this.info=void 0,this.key=e,this.info=t}static fromConfigData(e){let t=[...e];if(Ne(t)!==2)return null;let s=[];for(let o=0;o<2;o++){let i=new w(Te(t,0,Je)),a=je(t)===1;s.push({publicKey:i,isSigner:a})}if(s[0].publicKey.equals(Xi)&&s[1].isSigner){let o=bt().decode(P.Buffer.from(t)),i=JSON.parse(o);return qr(i,O_),new r(s[1].publicKey,i)}return null}},k_=new w("Vote111111111111111111111111111111111111111"),N_=u.struct([K("nodePubkey"),K("authorizedWithdrawer"),u.u8("commission"),u.nu64(),u.seq(u.struct([u.nu64("slot"),u.u32("confirmationCount")]),u.offset(u.u32(),-8),"votes"),u.u8("rootSlotValid"),u.nu64("rootSlot"),u.nu64(),u.seq(u.struct([u.nu64("epoch"),K("authorizedVoter")]),u.offset(u.u32(),-8),"authorizedVoters"),u.struct([u.seq(u.struct([K("authorizedPubkey"),u.nu64("epochOfLastAuthorizedSwitch"),u.nu64("targetEpoch")]),32,"buf"),u.nu64("idx"),u.u8("isEmpty")],"priorVoters"),u.nu64(),u.seq(u.struct([u.nu64("epoch"),u.nu64("credits"),u.nu64("prevCredits")]),u.offset(u.u32(),-8),"epochCredits"),u.struct([u.nu64("slot"),u.nu64("timestamp")],"lastTimestamp")]),Ls=class r{constructor(e){this.nodePubkey=void 0,this.authorizedWithdrawer=void 0,this.commission=void 0,this.rootSlot=void 0,this.votes=void 0,this.authorizedVoters=void 0,this.priorVoters=void 0,this.epochCredits=void 0,this.lastTimestamp=void 0,this.nodePubkey=e.nodePubkey,this.authorizedWithdrawer=e.authorizedWithdrawer,this.commission=e.commission,this.rootSlot=e.rootSlot,this.votes=e.votes,this.authorizedVoters=e.authorizedVoters,this.priorVoters=e.priorVoters,this.epochCredits=e.epochCredits,this.lastTimestamp=e.lastTimestamp}static fromAccountData(e){let n=N_.decode(z(e),4),s=n.rootSlot;return n.rootSlotValid||(s=null),new r({nodePubkey:new w(n.nodePubkey),authorizedWithdrawer:new w(n.authorizedWithdrawer),commission:n.commission,votes:n.votes,rootSlot:s,authorizedVoters:n.authorizedVoters.map(T_),priorVoters:L_(n.priorVoters),epochCredits:n.epochCredits,lastTimestamp:n.lastTimestamp})}};ki={http:{devnet:"http://api.devnet.solana.com",testnet:"http://api.testnet.solana.com","mainnet-beta":"http://api.mainnet-beta.solana.com/"},https:{devnet:"https://api.devnet.solana.com",testnet:"https://api.testnet.solana.com","mainnet-beta":"https://api.mainnet-beta.solana.com/"}};B_=1e9});export{kr as a,nn as b,ls as c,tn as d,vi as e,Je as f,w as g,fs as h,Cf as i,ht as j,fr as k,rn as l,sn as m,on as n,ft as o,At as p,Ze as q,Pt as r,Cs as s,rt as t,X as u,Y as v,hs as w,_s as x,He as y,Wf as z,$f as A,er as B,Dt as C,Vf as D,Gf as E,qf as F,tr as G,It as H,Hf as I,T as J,ps as K,Pi as L,ys as M,sr as N,gs as O,ee as P,_e as Q,Rs as R,Yf as S,ms as T,or as U,an as V,zi as W,Is as X,ar as Y,st as Z,ws as _,un as $,Os as aa,Ye as ba,dn as ca,cr as da,ur as ea,Yi as fa,dr as ga,wt as ha,ks as ia,de as ja,I_ as ka,zt as la,lr as ma,Ns as na,w_ as oa,Mt as pa,Xi as qa,Ts as ra,k_ as sa,Ls as ta,v_ as ua,C_ as va,B_ as wa,x_ as xa,P_ as ya};
